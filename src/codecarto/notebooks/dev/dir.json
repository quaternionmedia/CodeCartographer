{
  "info": {
    "name": "codecartographer",
    "owner": "quaternionmedia",
    "url": "https://github.com/quaternionmedia/codecartographer/"
  },
  "root": {
    "files": [
      {
        "name": ".dockerignore",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/.dockerignore",
        "size": 340,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/.dockerignore"
      },
      {
        "name": ".gitignore",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/.gitignore",
        "size": 2129,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/.gitignore"
      },
      {
        "name": ".gitmodules",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/.gitmodules",
        "size": 98,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/.gitmodules"
      },
      {
        "name": "LICENSE",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/LICENSE",
        "size": 1092,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/LICENSE"
      },
      {
        "name": "README.md",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/README.md",
        "size": 3064,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/README.md"
      },
      {
        "name": "docker-compose.yml",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docker-compose.yml",
        "size": 443,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docker-compose.yml"
      },
      {
        "name": "package-lock.json",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/package-lock.json",
        "size": 95,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/package-lock.json"
      },
      {
        "name": "poetry.lock",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/poetry.lock",
        "size": 182990,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/poetry.lock"
      },
      {
        "name": "pyproject.toml",
        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/pyproject.toml",
        "size": 1669,
        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/pyproject.toml"
      }
    ],
    "folders": [
      {
        "files": [],
        "folders": [
          {
            "files": [
              {
                "name": "parser.puml",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docs/.diagrams/parser.puml",
                "size": 1211,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docs/.diagrams/parser.puml"
              },
              {
                "name": "plotter.puml",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docs/.diagrams/plotter.puml",
                "size": 365,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docs/.diagrams/plotter.puml"
              },
              {
                "name": "user_sequence.puml",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docs/.diagrams/user_sequence.puml",
                "size": 1932,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/docs/.diagrams/user_sequence.puml"
              }
            ],
            "folders": [],
            "name": ".diagrams",
            "size": 3508
          }
        ],
        "name": "docs",
        "size": 3508
      },
      {
        "files": [],
        "folders": [
          {
            "files": [
              {
                "name": "Dockerfile",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/Dockerfile",
                "size": 1439,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/Dockerfile"
              },
              {
                "name": "__init__.py",
                "raw": "",
                "size": 0,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/__init__.py"
              },
              {
                "name": "main.py",
                "raw": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\nfrom routers.palette_router import PaletteRouter\nfrom routers.parser_router import ParserRouter\nfrom routers.plotter_router import PlotterRouter\nfrom routers.polygraph_router import PolygraphRouter\n\n\n# Debug\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\n# Create the app\napp = FastAPI()\n\n\n# TODO: this is here to test moe calling the api\norigins = [\n    \"http://localhost:1234\",  # web\n    \"http://localhost:5000\",  # moe\n]\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n# Catch all exceptions\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail},\n    )\n\n\n# Add the routers\napp.include_router(PaletteRouter, prefix=\"/palette\", tags=[\"palette\"])\napp.include_router(PlotterRouter, prefix=\"/plotter\", tags=[\"plotter\"])\napp.include_router(ParserRouter, prefix=\"/parser\", tags=[\"parser\"])\napp.include_router(PolygraphRouter, prefix=\"/polygraph\", tags=[\"polygraph\"])\n# app.include_router(GraphBaseRouter, prefix=\"/db\", tags=[\"db\"])\n",
                "size": 1344,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/main.py"
              },
              {
                "name": "requirements.txt",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/requirements.txt",
                "size": 193,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/requirements.txt"
              }
            ],
            "folders": [
              {
                "files": [
                  {
                    "name": "__init__.py",
                    "raw": "",
                    "size": 0,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/database/__init__.py"
                  },
                  {
                    "name": "database.py",
                    "raw": "from models.graph_data import GraphBase\nfrom models.plot_data import DefaultPalette, Palette\n\n\nclass DatabaseContext:\n    @staticmethod\n    async def fetch_graph_by_id(graph_id: str) -> GraphBase:\n        # Placeholder for DB fetch logic\n        return GraphBase()\n\n    @staticmethod\n    async def fetch_palette_by_id(palette_id: str) -> Palette:\n        # Placeholder for DB fetch logic\n        return DefaultPalette\n",
                    "size": 418,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/database/database.py"
                  }
                ],
                "folders": [],
                "name": "database",
                "size": 418
              },
              {
                "files": [
                  {
                    "name": "__init__.py",
                    "raw": "",
                    "size": 0,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/__init__.py"
                  },
                  {
                    "name": "demo_data.py",
                    "raw": "import networkx as nx\n\nfrom models.graph_data import GraphBase\n\nDemoGraph: GraphBase = GraphBase(\n    nx.DiGraph(\n        name=\"Demo\",\n        incoming_graph_data={\n            \"nodes\": [\n                (1, {\"type\": \"module\", \"label\": \"module\"}),\n                (2, {\"type\": \"function\", \"label\": \"function_a\"}),\n                (3, {\"type\": \"class\", \"label\": \"class_a\"}),\n                (4, {\"type\": \"variables\", \"label\": \"variables_a\"}),\n                (5, {\"type\": \"import\", \"label\": \"import_a\"}),\n                (6, {\"type\": \"function\", \"label\": \"function_b\"}),\n                (7, {\"type\": \"class\", \"label\": \"class_b\"}),\n                (8, {\"type\": \"variables\", \"label\": \"variables_b\"}),\n                (9, {\"type\": \"function\", \"label\": \"function_c\"}),\n                (10, {\"type\": \"function\", \"label\": \"function_d\"}),\n                (11, {\"type\": \"class\", \"label\": \"class_c\"}),\n                (12, {\"type\": \"variables\", \"label\": \"variables_c\"}),\n            ],\n            \"edges\": [\n                (1, 2),\n                (1, 3),\n                (1, 4),\n                (1, 5),\n                (2, 6),\n                (3, 7),\n                (4, 8),\n                (6, 9),\n                (7, 10),\n                (9, 11),\n                (10, 12),\n            ],\n        },\n    )\n)\n",
                    "size": 1301,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/demo_data.py"
                  },
                  {
                    "name": "graph_data.py",
                    "raw": "from fileinput import filename\nfrom networkx import DiGraph\nfrom pydantic import BaseModel, Field\n\n\nclass Edge(BaseModel):\n    id: int\n    type: str = \"\"\n    source: int\n    target: int\n\n\nclass Node(BaseModel):\n    id: int\n    type: str\n    label: str = \"\"\n    base: str = \"\"\n    parent: int\n    children: list[\"Node\"] = []\n    edges: list[Edge] = []\n\n\nclass GraphBase:\n    # TODO: Flesh this out a bit more\n    # gravis graphs need a bit more\n    # structure than just a networkx graph\n    #   look in notebook around X and Y\n    def __init__(self, graph=DiGraph()):\n        self.graph = graph\n\n\nclass GraphBuilder:\n    def __init__(self):\n        self.graph = DiGraph()\n\n    def add_node(self, node: Node):\n        self.graph.add_node(\n            node.id, type=node.type, label=node.label, parent=node.parent\n        )\n        if node.parent is not None:\n            self.graph.add_edge(node.parent, node.id)\n\n    def add_edge(self, edge: Edge):\n        self.graph.add_edge(edge.source, edge.target)\n\n    def get_graph(self):\n        return self.graph\n",
                    "size": 1055,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/graph_data.py"
                  },
                  {
                    "name": "plot_data.py",
                    "raw": "from numpy import size\nfrom pydantic import BaseModel\nfrom typing import Callable, Dict\n\n\nclass RawData:\n    def __init__(self, name: str, raw: str):\n        self.name = name\n        self.raw = raw\n\n\nclass FileGraphData(BaseModel):\n    name: str = \"\"\n    size: int = 0\n    raw: str = \"\"\n    layout: str = \"Spring\"\n\n\nclass LayoutType(dict):\n    name: str\n    func: Callable\n    params: list[str]\n\n\nclass PlotOptions(BaseModel):\n    palette_id: str = \"0\"\n    layout: str = \"Spring\"\n    type: str = \"d3\"\n\n\nclass Palette(BaseModel):\n    id: str\n    bases: Dict[str, str]\n    labels: Dict[str, str]\n    alphas: Dict[str, float]\n    sizes: Dict[str, int]\n    shapes: Dict[str, str]\n    colors: Dict[str, str]\n\n\nDefaultPalette = Palette(\n    id=\"0\",\n    bases={\n        \"Unknown\": \"unknown\",\n        \"Async\": \"async\",\n        \"AsyncFor\": \"async.for\",\n        \"AsyncWith\": \"async.with\",\n        \"AsyncFunctionDef\": \"async.function\",\n        \"Control\": \"control\",\n        \"Conditional\": \"control.cond\",\n        \"Break\": \"control.break\",\n        \"Continue\": \"control.continue\",\n        \"ExceptHandler\": \"control\",\n        \"For\": \"control.loop.for\",\n        \"If\": \"control.cond.if\",\n        \"Try\": \"control.try\",\n        \"While\": \"control.loop.while\",\n        \"With\": \"control.loop.with\",\n        \"Definitions\": \"def\",\n        \"ClassDef\": \"def.class\",\n        \"FunctionDef\": \"def.function\",\n        \"Global\": \"def.global\",\n        \"Nonlocal\": \"def.nonlocal\",\n        \"Return\": \"def\",\n        \"Yield\": \"def\",\n        \"YieldFrom\": \"def\",\n        \"Argument\": \"deprecated\",\n        \"Body\": \"deprecated\",\n        \"Bytes\": \"deprecated\",\n        \"Ellipsis\": \"deprecated\",\n        \"ExtSlice\": \"deprecated\",\n        \"Float\": \"deprecated\",\n        \"Index\": \"deprecated\",\n        \"Int\": \"deprecated\",\n        \"Loop\": \"deprecated\",\n        \"Method\": \"deprecated\",\n        \"NameConstant\": \"deprecated\",\n        \"Num\": \"deprecated\",\n        \"Str\": \"deprecated\",\n        \"Expressions\": \"expr\",\n        \"Attribute\": \"expr\",\n        \"BinOp\": \"expr\",\n        \"BoolOp\": \"expr\",\n        \"Call\": \"expr\",\n        \"Compare\": \"expr\",\n        \"Expr\": \"expr\",\n        \"IfExp\": \"expr\",\n        \"UnaryOp\": \"expr\",\n        \"Slice\": \"expr.subscript\",\n        \"Subscript\": \"expr.subscript\",\n        \"DictComp\": \"expr.comp\",\n        \"GeneratorExp\": \"expr.comp\",\n        \"ListComp\": \"expr.comp\",\n        \"SetComp\": \"expr.comp\",\n        \"Literals\": \"literals\",\n        \"Constant\": \"literals.constant\",\n        \"Dict\": \"literals.dict\",\n        \"List\": \"literals\",\n        \"Set\": \"literals\",\n        \"Tuple\": \"literals\",\n        \"Match\": \"match\",\n        \"MatchAs\": \"match\",\n        \"MatchClass\": \"match\",\n        \"MatchMap\": \"match\",\n        \"MatchOr\": \"match\",\n        \"MatchSequence\": \"match\",\n        \"MatchSingleton\": \"match\",\n        \"MatchStar\": \"match\",\n        \"MatchValue\": \"match\",\n        \"Module\": \"module\",\n        \"FunctionType\": \"module\",\n        \"Interactive\": \"module\",\n        \"Statements\": \"statements\",\n        \"AnnAssign\": \"statements\",\n        \"Assert\": \"statements\",\n        \"Assign\": \"statements\",\n        \"Delete\": \"statements\",\n        \"Pass\": \"statements\",\n        \"Raise\": \"statements\",\n        \"Import\": \"statements.import\",\n        \"ImportFrom\": \"statements.importfrom\",\n        \"Variable\": \"variables\",\n        \"Name\": \"variables\",\n    },\n    labels={\n        \"unknown\": \"u\",\n        \"async\": \"@\",\n        \"async.for\": \"@for\",\n        \"async.with\": \"@wi\",\n        \"async.function\": \"@Fn\",\n        \"control\": \"c\",\n        \"control.cond\": \"cc\",\n        \"control.cond.loop\": \"ccl\",\n        \"control.break\": \"brk\",\n        \"control.continue\": \"cont\",\n        \"control.loop.for\": \"for\",\n        \"control.cond.if\": \"if\",\n        \"control.try\": \"try\",\n        \"control.loop.while\": \"wh\",\n        \"control.loop.with\": \"wi\",\n        \"def\": \"d\",\n        \"def.class\": \"Cl\",\n        \"def.function\": \"Fn\",\n        \"def.global\": \"gl\",\n        \"def.nonlocal\": \"nl\",\n        \"deprecated\": \"x\",\n        \"expr\": \"e\",\n        \"expr.subscript\": \"sbscpt\",\n        \"expr.comp\": \"comp\",\n        \"literals\": \"l\",\n        \"literals.constant\": \"const\",\n        \"literals.dict\": \"dict\",\n        \"match\": \"mat\",\n        \"module\": \"Mod\",\n        \"statements\": \"s\",\n        \"statements.import\": \"I\",\n        \"statements.importfrom\": \"IF\",\n        \"variables\": \"var\",\n    },\n    alphas={\n        \"unknown\": 0.3,\n        \"async\": 0.3,\n        \"async.for\": 0.3,\n        \"async.with\": 0.3,\n        \"async.function\": 0.3,\n        \"control\": 0.3,\n        \"control.cond\": 0.3,\n        \"control.cond.loop\": 0.3,\n        \"control.break\": 0.3,\n        \"control.continue\": 0.3,\n        \"control.loop.for\": 0.3,\n        \"control.cond.if\": 0.3,\n        \"control.try\": 0.3,\n        \"control.loop.while\": 0.3,\n        \"control.loop.with\": 0.3,\n        \"def\": 0.3,\n        \"def.class\": 0.3,\n        \"def.function\": 0.3,\n        \"def.global\": 0.3,\n        \"def.nonlocal\": 0.3,\n        \"deprecated\": 0.3,\n        \"expr\": 0.5,\n        \"expr.subscript\": 0.5,\n        \"expr.comp\": 0.5,\n        \"literals\": 0.3,\n        \"literals.constant\": 0.3,\n        \"literals.dict\": 0.3,\n        \"match\": 0.3,\n        \"module\": 0.5,\n        \"statements\": 0.3,\n        \"statements.import\": 0.3,\n        \"statements.importfrom\": 0.3,\n        \"variables\": 0.5,\n    },\n    sizes={\n        \"unknown\": 400,\n        \"async\": 400,\n        \"async.for\": 400,\n        \"async.with\": 400,\n        \"async.function\": 800,\n        \"control\": 400,\n        \"control.cond\": 400,\n        \"control.cond.loop\": 400,\n        \"control.break\": 400,\n        \"control.continue\": 400,\n        \"control.loop.for\": 400,\n        \"control.cond.if\": 400,\n        \"control.try\": 400,\n        \"control.loop.while\": 400,\n        \"control.loop.with\": 400,\n        \"def\": 400,\n        \"def.class\": 1000,\n        \"def.function\": 800,\n        \"def.global\": 600,\n        \"def.nonlocal\": 400,\n        \"deprecated\": 400,\n        \"expr\": 400,\n        \"expr.subscript\": 400,\n        \"expr.comp\": 400,\n        \"literals\": 400,\n        \"literals.constant\": 600,\n        \"literals.dict\": 400,\n        \"match\": 400,\n        \"module\": 1000,\n        \"statements\": 400,\n        \"statements.import\": 800,\n        \"statements.importfrom\": 800,\n        \"variables\": 400,\n    },\n    shapes={\n        \"unknown\": \"o\",\n        \"async\": \"^\",\n        \"async.for\": \"^\",\n        \"async.with\": \"^\",\n        \"async.function\": \"^\",\n        \"control\": \"s\",\n        \"control.cond\": \"s\",\n        \"control.cond.loop\": \"s\",\n        \"control.break\": \"s\",\n        \"control.continue\": \"s\",\n        \"control.loop.for\": \"s\",\n        \"control.cond.if\": \"s\",\n        \"control.try\": \"s\",\n        \"control.loop.while\": \"s\",\n        \"control.loop.with\": \"s\",\n        \"def\": \"H\",\n        \"def.class\": \"H\",\n        \"def.function\": \"H\",\n        \"def.global\": \"H\",\n        \"def.nonlocal\": \"H\",\n        \"deprecated\": \"x\",\n        \"expr\": \"<\",\n        \"expr.subscript\": \"<\",\n        \"expr.comp\": \"<\",\n        \"literals\": \">\",\n        \"literals.constant\": \">\",\n        \"literals.dict\": \">\",\n        \"match\": \"D\",\n        \"module\": \"s\",\n        \"statements\": \"d\",\n        \"statements.import\": \"d\",\n        \"statements.importfrom\": \"d\",\n        \"variables\": \"o\",\n    },\n    colors={\n        \"unknown\": \"gray\",\n        \"async\": \"pink\",\n        \"async.for\": \"pink\",\n        \"async.with\": \"pink\",\n        \"async.function\": \"pink\",\n        \"control\": \"orange\",\n        \"control.cond\": \"green\",\n        \"control.cond.loop\": \"maroon\",\n        \"control.break\": \"violet\",\n        \"control.continue\": \"violet\",\n        \"control.loop.for\": \"maroon\",\n        \"control.cond.if\": \"green\",\n        \"control.try\": \"green\",\n        \"control.loop.while\": \"maroon\",\n        \"control.loop.with\": \"maroon\",\n        \"def\": \"purple\",\n        \"def.class\": \"purple\",\n        \"def.function\": \"purple\",\n        \"def.global\": \"purple\",\n        \"def.nonlocal\": \"purple\",\n        \"deprecated\": \"red\",\n        \"expr\": \"khaki\",\n        \"expr.subscript\": \"khaki\",\n        \"expr.comp\": \"khaki\",\n        \"literals\": \"gold\",\n        \"literals.constant\": \"gold\",\n        \"literals.dict\": \"gold\",\n        \"match\": \"salmon\",\n        \"module\": \"red\",\n        \"statements\": \"blue\",\n        \"statements.import\": \"lightblue\",\n        \"statements.importfrom\": \"darkblue\",\n        \"variables\": \"skyblue\",\n    },\n)\n",
                    "size": 8301,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/plot_data.py"
                  },
                  {
                    "name": "source_data.py",
                    "raw": "# TODO: SourceData will be used by the parser\n# is could be a single file, a folder of files,\n# or a folder of folders and/or files\n\n# the files will have names and raw data content, buth in sting format\n# the folders will have names and a list of files and/or folders\n\nfrom pydantic import BaseModel\nfrom typing import List, Union\n\n\nclass File(BaseModel):\n    name: str\n    size: int\n    raw: str\n\n\nclass Folder(BaseModel):\n    name: str\n    size: int\n    files: list[File]\n    folders: list[\"Folder\"]\n\n\nclass SourceData(BaseModel):\n    name: str\n    size: int\n    source: List[Union[File, Folder]]\n",
                    "size": 600,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/source_data.py"
                  }
                ],
                "folders": [
                  {
                    "files": [
                      {
                        "name": "__init__.py",
                        "raw": "",
                        "size": 0,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/custom_layouts/__init__.py"
                      },
                      {
                        "name": "arch_layout.py",
                        "raw": "import matplotlib.pyplot as plt\nimport networkx as nx\n\ndef arc_layout(G):\n    pos = nx.spring_layout(G)  # To make the initial layout more interesting\n    nodes = G.nodes()\n    plt.figure(figsize=(8, 4))\n    # Draw nodes\n    for node in nodes:\n        plt.scatter(pos[node][0], 0, s=100, c='blue')\n\n    # Draw edges\n    for edge in G.edges():\n        start, end = pos[edge[0]], pos[edge[1]]\n        x = [start[0], end[0]]\n        y = [0, 0]\n        plt.plot(x, y, c='red', alpha=0.5, zorder=1)\n\n    # Remove y-axis\n    plt.gca().axes.get_yaxis().set_visible(False)\n\n    # Show the plot\n    plt.show() ",
                        "size": 601,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/custom_layouts/arch_layout.py"
                      },
                      {
                        "name": "cluster_layout.py",
                        "raw": "import numpy as np\n\ndef cluster_layout(G, root, radius=1):\n    positions = {root: np.array([0, 0])}  # Initialize the positions dictionary with the root at the center\n    unvisited = set(G.nodes()) - {root}  # Nodes that haven't been visited yet\n\n    stack = [(root, 0, 2*np.pi, radius)]  # Initialize the stack with the root, start_angle, end_angle, and depth\n\n    while stack:\n        node, angle, d_angle, depth = stack.pop()  # Pop a node from the stack\n        children = list(G.neighbors(node))\n        num_children = len(children)\n        for i, child in enumerate(children):\n            child_angle = angle - d_angle/2 + i*d_angle/num_children  # calculate the angle for the child\n            positions[child] = depth * np.array([np.cos(child_angle), np.sin(child_angle)])  # calculate the position for the child\n            stack.append((child, child_angle, d_angle/num_children, depth+radius))  # add the child to the stack\n\n    # Process unvisited nodes, if any\n    while unvisited:\n        node = unvisited.pop()\n        if node in positions:  # If we've already visited the node, continue\n            continue\n        parents = list(G.predecessors(node))  # Get the node's parents\n        if parents:  # If the node has parents\n            parent = parents[0]  # Assume that the node has only one parent\n            if parent in positions:  # If the parent has been visited\n                positions[node] = positions[parent]  # Position the node at the parent's position\n                # Layout the subgraph rooted at the node, iteratively\n                stack.append((node, 0, 2*np.pi, radius))\n\n    return positions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# import math \n\n# def create_clusters(G, root):\n#     clusters = {}\n#     visited = set()\n\n#     def dfs(node):\n#         visited.add(node)\n#         clusters[node] = []\n#         for child in G.neighbors(node):\n#             if child not in visited:\n#                 clusters[node].append(child)\n#                 dfs(child)\n    \n#     dfs(root)\n#     return clusters\n\n# def cluster_layout(G, root):\n#     clusters = create_clusters(G, root)\n#     positions = {root: (0, 0)}\n\n#     def count_nodes(node):\n#         return 1 + sum(count_nodes(child) for child in clusters[node])\n\n#     node_sizes = {node: count_nodes(node) for node in clusters}\n\n#     def layout_clusters(node, radius, start_angle, end_angle):\n#         children = clusters[node]\n#         if not children:\n#             return\n#         total_size = sum(node_sizes[child] for child in children)\n#         angle_step = (end_angle - start_angle) / max(total_size, 1)\n#         angle = start_angle\n#         for child in children:\n#             child_size = node_sizes[child]\n#             mid_angle = angle + angle_step * child_size / 2\n#             x = radius * math.cos(mid_angle)\n#             y = radius * math.sin(mid_angle)\n#             positions[child] = (x, y)\n#             layout_clusters(child, radius + 1, angle, angle + angle_step * child_size)\n#             angle += angle_step * child_size\n\n#     layout_clusters(root, 1, 0, 2 * math.pi)\n#     return positions\n",
                        "size": 3096,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/custom_layouts/cluster_layout.py"
                      },
                      {
                        "name": "sorted_square_layout.py",
                        "raw": "import networkx as nx\n\ndef sorted_square_layout(G: nx.Graph):\n    \"\"\"Position nodes in a grid.\n\n    Parameters\n    ----------\n    G : NetworkX graph or list of nodes\n        A position will be assigned to every node in G.\n\n    Returns\n    -------\n    pos : dict\n        A dictionary of positions keyed by node\n    \"\"\"\n    import math\n    import numpy as np \n\n    num_nodes = len(G.nodes())\n    sqrt_num_nodes = math.sqrt(num_nodes)\n    grid_size = math.ceil(sqrt_num_nodes) \n\n    # Sort nodes by 'type' attribute\n    sorted_nodes = sorted(G.nodes(data=True), key=lambda x: x[1][\"type\"])\n\n    # Create a grid of positions\n    positions = np.array([(x, y) for x in range(grid_size) for y in range(grid_size)])\n\n    # Create a mapping from node to position\n    pos = {node: pos for (node, _attr), pos in zip(sorted_nodes, positions)}\n\n    return pos ",
                        "size": 847,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/models/custom_layouts/sorted_square_layout.py"
                      }
                    ],
                    "folders": [],
                    "name": "custom_layouts",
                    "size": 4544
                  }
                ],
                "name": "models",
                "size": 15801
              },
              {
                "files": [
                  {
                    "name": "gravis_all.ipynb",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_all.ipynb",
                    "size": 2119,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_all.ipynb"
                  },
                  {
                    "name": "gravis_d3.ipynb",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_d3.ipynb",
                    "size": 1392,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_d3.ipynb"
                  },
                  {
                    "name": "gravis_three.ipynb",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_three.ipynb",
                    "size": 595,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_three.ipynb"
                  },
                  {
                    "name": "gravis_vis.ipynb",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_vis.ipynb",
                    "size": 589,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/gravis_vis.ipynb"
                  },
                  {
                    "name": "notebook.py",
                    "raw": "import gravis as gv\nimport nbformat\nfrom nbconvert.preprocessors import ExecutePreprocessor\nimport networkx as nx\nfrom models.graph_data import GraphBase\nfrom models.plot_data import DefaultPalette, PlotOptions\nfrom services.plotter_service import PlotterService\nfrom services.position_service import Positions\nfrom util.exceptions import NotebookError\n\n\nasync def run_notebook(\n    graph_name: str, graph: nx.DiGraph, title: str = \"Spectral\", type: str = \"d3\"\n) -> list:\n    \"\"\"Extract the outputs from a notebook.\n\n    Parameters:\n    -----------\n    graph_name : str\n        The name of the graph to read from database.\n    graph : nx.DiGraph\n        The graph to plot.\n    title : str\n        The name of the layout to plot.\n    type : str\n        The type of graph to plot in the notebook.\n\n    Returns:\n    --------\n    list\n        The list of outputs.\n    \"\"\"\n\n    # Check if graph provided\n    if not graph:\n        raise NotebookError(\n            \"run_notebook\",\n            {\"graph_name\": graph_name, \"graph\": graph},\n            \"No graph provided\",\n        )\n\n    # make possible multigraphs into a digraph\n    ntxGraph = nx.DiGraph(graph)\n    graphBase = GraphBase()\n    graphBase.graph = ntxGraph\n    root = \"notebooks/\"\n\n    # Set and scale up the postiions\n    plot = PlotterService()\n    plot.plot_graph(graphBase, DefaultPalette, PlotOptions())\n    pos = Positions().get_node_positions(\n        graph=graph, layout_name=f\"{title.lower()}_layout\"\n    )\n    spread = 100\n    if title == \"Spectral\":\n        spread = 500\n    for id, (x, y) in pos.items():\n        node = graph.nodes[id]\n        node[\"x\"] = float(x) * spread\n        node[\"y\"] = float(y) * spread\n\n    # Scale nodes based on edges\n    for node, data in graph.nodes(data=True):\n        # Set size based on the number of outgoing edges\n        data[\"size\"] = (\n            1 + (len(graph.out_edges(node)) * 10) + (len(graph.in_edges(node)) * 10)\n        )\n\n    # Convert the graph to gJGF for the notebook\n    gJFG = gv.convert.any_to_gjgf(graph)\n\n    # Read in the notebook\n    nb_path = f\"{root}gravis_{type}.ipynb\"\n    with open(nb_path, \"r\", encoding=\"utf-8\") as f:\n        nb = nbformat.read(f, as_version=4)\n\n        # Create a new code cell with the graph_data (g)\n        param_cell = nbformat.v4.new_code_cell(f\"g = {gJFG}\")\n\n        # Insert the cell at the beginning of the notebook\n        nb.cells.insert(0, param_cell)\n\n    # Execute the notebook\n    ep = ExecutePreprocessor(timeout=600)\n    ep.preprocess(nb, {\"metadata\": {\"path\": root}})\n\n    # Extract the outputs\n    outputs = []\n    for cell in nb.cells:\n        if cell.cell_type == \"code\":\n            for output in cell.outputs:\n                if output.output_type == \"execute_result\":\n                    outputs.append(output.data)\n\n    # Return the outputs\n    return outputs\n",
                    "size": 2835,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/notebooks/notebook.py"
                  }
                ],
                "folders": [],
                "name": "notebooks",
                "size": 7530
              },
              {
                "files": [
                  {
                    "name": "__init__.py",
                    "raw": "",
                    "size": 0,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/routers/__init__.py"
                  },
                  {
                    "name": "palette_router.py",
                    "raw": "from fastapi import APIRouter\nfrom util.exceptions import proc_exception\nfrom util.utilities import Log, generate_return\n\nPaletteRouter = APIRouter()\n\n\n@PaletteRouter.get(\"/default\")\nasync def get_default_palette():\n    from models.plot_data import DefaultPalette\n\n    try:\n        return generate_return(\n            message=\"get_default_palette - Success\", results=DefaultPalette.dict()\n        )\n    except Exception as e:\n        return proc_exception(\n            \"get_palette\",\n            \"Error getting default palette\",\n            {},\n            e,\n        )\n\n\n@PaletteRouter.get(\"/custom\")\nasync def get_custom_palette(palette_id: str):\n    from database.database import DatabaseContext\n\n    try:\n        palette = await DatabaseContext.fetch_palette_by_id(palette_id)\n        return generate_return(\n            message=\"get_custom_palette - Success\", results=palette.dict()\n        )\n    except Exception as e:\n        return proc_exception(\n            \"get_palette\",\n            \"Error getting custom palette\",\n            {},\n            e,\n        )\n",
                    "size": 1068,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/routers/palette_router.py"
                  },
                  {
                    "name": "parser_router.py",
                    "raw": "from re import L\nfrom fastapi import APIRouter\nfrom models.source_data import File, SourceData\nfrom util.exceptions import proc_exception, proc_error\nfrom util.utilities import Log, generate_return\n\n\nParserRouter = APIRouter()\n\n\n@ParserRouter.get(\"/url\")\nasync def read_github_url(url: str):\n    import time\n    from services.github_service import (\n        ImportSourceUrlError,\n        GithubError,\n        get_github_repo_content,\n        get_repo_tree,\n    )\n\n    try:\n        # get current time to calculate total time taken\n        start_time = time.time()\n\n        # Extract owner and repo from the URL: https://github.com/owner/repo\n        parts = url.split(\"/\")\n        if len(parts) < 5 or parts[2] != \"github.com\":\n            return proc_error(\"read_github_url\", \"Invalid GitHub URL format\")\n\n        owner, repo = parts[3], parts[4]\n        url_content = await get_github_repo_content(url, owner, repo, \"\", True)\n\n        # check if url_content is empty or an Error response\n        if not url_content or len(url_content) == 0:\n            if \"status\" in url_content:\n                Log.error(f\"Error response from GitHub: {url_content}\")\n            return proc_error(\"read_github_url\", \"Empty contents received from GitHub\")\n\n        repo_contents = {\"package_owner\": owner, \"package_name\": repo, \"contents\": {}}\n        contents: dict = await get_repo_tree(url_content, owner, repo)\n\n        # check if contents is empty or an Error response\n        if not contents or len(contents) == 0:\n            if \"status\" in contents:\n                Log.error(f\"Error response from GitHub: {contents}\")\n            return proc_error(\"read_github_url\", \"Could not parse file content\")\n\n        repo_contents[\"contents\"] = contents\n        return generate_return(200, \"read_github_url - Success\", repo_contents)\n    except GithubError as exc:\n        proc_exception(\n            exc.source,\n            exc.message,\n            exc.params,\n            exc,\n        )\n    except ImportSourceUrlError as exc:\n        proc_exception(\n            exc.source,\n            exc.message,\n            exc.params,\n            exc,\n        )\n    except Exception as exc:\n        proc_exception(\n            \"read_github_url\",\n            \"Error when reading GitHub URL\",\n            {\"github_url\": url},\n            exc,\n        )\n    finally:\n        # calculate total time taken\n        end_time = time.time()\n        total_time = time.strftime(\"%H:%M:%S\", time.gmtime(end_time - start_time))\n        # TODO: Log this in database later\n        Log.info(f\"  Total time taken: {total_time}\")\n\n\n@ParserRouter.post(\"/source\")\nasync def parse_source(source: SourceData) -> dict:\n    return parse(source)\n\n\n@ParserRouter.post(\"/file\")\nasync def parse_file(file: File) -> dict:\n    source = SourceData(name=file.name, size=file.size, source=[file])\n    return parse(source)\n\n\n@ParserRouter.post(\"/raw\")\nasync def parse_raw(raw: str) -> dict:\n    file = File(name=\"raw\", size=len(raw), raw=raw)\n    source = SourceData(name=\"raw\", size=len(raw), source=[file])\n    return parse(source)\n\n\ndef parse(source: SourceData) -> dict:\n    from services.ASTs.python_ast import PythonAST\n    from services.parser_service import ParserService\n    from services.polygraph_service import graph_to_json_data\n\n    try:\n        parser_service = ParserService(visitor=PythonAST())\n        graph = parser_service.parse(source)\n        result = graph_to_json_data(graph)\n        return generate_return(200, \"parse - Success\", {\"contents\": result})\n    except Exception as e:\n        return proc_exception(\n            \"parse\",\n            \"error parsing data\",\n            {\"source\": source},\n            e,\n        )\n",
                    "size": 3690,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/routers/parser_router.py"
                  },
                  {
                    "name": "plotter_router.py",
                    "raw": "from fastapi import APIRouter\nfrom models.plot_data import DefaultPalette, PlotOptions, FileGraphData\nfrom util.exceptions import proc_exception\nfrom util.utilities import Log, generate_return\n\nPlotterRouter = APIRouter()\n\n\n@PlotterRouter.post(\"/raw\")\nasync def plot_from_raw(data: FileGraphData) -> dict:\n    # TODO: raw is a placeholder for now\n    # really this should parse from parser service\n    # save it to the database and return an id\n    # and then plot from plotter service using that id\n    import networkx as nx\n    from notebooks.notebook import run_notebook\n    from services.palette_service import apply_styles\n    from models.source_data import SourceData, File\n    from services.ASTs.python_ast import PythonAST\n    from services.parser_service import ParserService\n\n    try:\n        # parse the raw data\n        file = File(name=data.name, size=data.size, raw=data.raw)\n        source = SourceData(name=data.name, size=data.size, source=[file])\n        parser = ParserService(PythonAST())\n        graph = parser.parse(source)\n\n        # Run the notebook on the graph\n        results = await run_notebook(\n            graph_name=data.name,\n            graph=apply_styles(graph),\n            title=data.layout,\n            type=\"d3\",\n        )\n        return generate_return(message=\"plot_from_file - Success\", results=results)\n    except Exception as e:\n        return proc_exception(\n            \"plot_from_file\",\n            \"Error generating plot\",\n            {\"file\": data.name},\n            e,\n        )\n\n\n@PlotterRouter.post(\"/url\")\nasync def plot_from_url(url: str, options: PlotOptions) -> dict:\n    # TODO: Url is a placeholder for now\n    # really this should parse from parser service\n    # save it to the database and return an id\n    # and then plot from plotter service using that id\n    from database.database import DatabaseContext\n    from models.source_data import File, SourceData\n    from models.graph_data import GraphBase\n    from services.ASTs.python_ast import PythonAST\n    from services.parser_service import ParserService\n    from services.plotter_service import PlotterService\n    from services.github_service import get_raw_data_from_github_url\n    from notebooks.notebook import run_notebook\n    from services.palette_service import apply_styles\n\n    try:\n        raw = await get_raw_data_from_github_url(url)\n        file = File(name=\"raw\", size=0, raw=raw)\n        source = SourceData(name=file.name, size=file.size, source=[file])\n        parser = ParserService(PythonAST())\n        graph = parser.parse(source)\n\n        # TODO: TEMPORARY Run the notebook on the graph\n        results = await run_notebook(\n            graph_name=file.name,\n            graph=apply_styles(graph),\n            title=options.layout,\n            type=options.type,\n        )\n        # graphbase = GraphBase(graph)\n        # palette = await DatabaseContext.fetch_palette_by_id(options.palette_id)\n        # results = PlotterService.plot_graph(\n        #     graph=graphbase, palette=palette, options=options\n        # )\n        return generate_return(message=\"plot_from_url - Success\", results=results)\n    except Exception as e:\n        return proc_exception(\n            \"plot_from_url\",\n            \"Error generating plot\",\n            {\"url\": url},\n            e,\n        )\n\n\n@PlotterRouter.post(\"/json\")\nasync def plot_from_json(json_graph: dict, options: PlotOptions) -> dict:\n    from services.polygraph_service import PolygraphService\n    from database.database import DatabaseContext\n    from services.plotter_service import PlotterService\n\n    try:\n        graph = await PolygraphService.json_to_graph(json_graph)\n        palette = await DatabaseContext.fetch_palette_by_id(options.palette_id)\n        results = PlotterService.plot_graph(\n            graph=graph, palette=palette, options=options\n        )\n        return generate_return(message=\"plot_from_json - Success\", results=results)\n    except Exception as e:\n        return proc_exception(\n            \"plot_from_json\",\n            \"Error generating plot\",\n            {\"json_graph\": json_graph},\n            e,\n        )\n\n\n@PlotterRouter.post(\"/db\")\nasync def plot_from_db(graph_id: str, options: PlotOptions) -> dict:\n    from database.database import DatabaseContext\n    from services.plotter_service import PlotterService\n\n    try:\n        graph = await DatabaseContext.fetch_graph_by_id(graph_id)\n        palette = await DatabaseContext.fetch_palette_by_id(options.palette_id)\n        results = PlotterService.plot_graph(\n            graph=graph, palette=palette, options=options\n        )\n        return generate_return(message=\"plot_from_db - Success\", results=results)\n    except Exception as e:\n        return proc_exception(\n            \"plot_from_db\",\n            \"Error generating plot\",\n            {\"graph_id\": graph_id},\n            e,\n        )\n\n\n@PlotterRouter.post(\"/demo\")\nasync def plot_from_demo(options: PlotOptions) -> dict:\n    from models.demo_data import DemoGraph\n    from services.plotter_service import PlotterService\n\n    try:\n        graph = DemoGraph\n        palette = DefaultPalette\n        results = PlotterService.plot_graph(\n            graph=graph, palette=palette, options=options\n        )\n        return generate_return(message=\"plot_from_demo - Success\", results=results)\n    except Exception as e:\n        return proc_exception(\n            \"plot_from_db\",\n            \"Error generating plot\",\n            {\"\": \"\"},\n            e,\n        )\n",
                    "size": 5484,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/routers/plotter_router.py"
                  },
                  {
                    "name": "polygraph_router.py",
                    "raw": "from fastapi import APIRouter\nfrom util.exceptions import proc_exception\nfrom util.utilities import Log, generate_return\n\nPolygraphRouter = APIRouter()\n",
                    "size": 152,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/routers/polygraph_router.py"
                  }
                ],
                "folders": [],
                "name": "routers",
                "size": 10394
              },
              {
                "files": [
                  {
                    "name": "__init__.py",
                    "raw": "",
                    "size": 0,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/__init__.py"
                  },
                  {
                    "name": "github_service.py",
                    "raw": "import httpx\nfrom util.exceptions import (\n    GithubError,\n    Github404Error,\n    GithubNoDataError,\n    GithubSizeError,\n    GithubAPIError,\n    ImportSourceUrlError,\n    ImportSourceUrlHttpError,\n)\nfrom util.utilities import Log\n\n\n########################   OLD CODE   ########################\nasync def get_github_repo_content(\n    url: str,\n    owner: str,\n    repo: str,\n    path: str = \"\",\n    first: bool = False,\n) -> list[dict] | dict:\n    \"\"\"Reads GitHub content from a URL\n\n    Parameters:\n        url {str} -- URL to read from\n        owner {str} -- Owner of the GitHub repo\n        repo {str} -- Name of the GitHub repo\n        path {str} -- Path to the file or directory to read from\n        first {bool} -- Whether this is the first call to this function\n\n    Returns:\n        list[dict] | dict -- List of dictionaries containing GitHub file content\n    \"\"\"\n    try:\n        client = httpx.AsyncClient()\n\n        # Construct the API URL\n        with open(\"/run/secrets/github_token\", \"r\") as file:\n            GIT_API_KEY = file.read().strip()\n        if not GIT_API_KEY or GIT_API_KEY == \"\":\n            raise GithubAPIError(\n                \"get_github_repo_content\", {\"github_url\": url, \"api_url\": \"nothing\"}\n            )\n\n        headers = {\n            \"Accept\": \"application/vnd.github.v3+json\",\n            # Uncomment and set your token if you have one\n            \"Authorization\": f\"token {GIT_API_KEY}\",\n        }\n\n        # get the size of the whole repo\n        if first:\n            api_url = f\"https://api.github.com/repos/{owner}/{repo}\"\n            response = await client.get(\n                api_url, headers=headers, follow_redirects=False\n            )\n            if response.status_code == 200:\n                json_data = response.json()\n                if json_data[\"size\"]:\n                    size = json_data[\"size\"]\n                    Log.info(f\"  Repo Size: {size} bytes\")\n                    if size > 1000000:\n                        raise GithubSizeError(\n                            \"get_github_repo_content\",\n                            {\"github_url\": url, \"api_url\": api_url},\n                        )\n\n        # get the actual contents of the repo\n        api_url = f\"https://api.github.com/repos/{owner}/{repo}/contents/{path}\"\n        response = await client.get(api_url, headers=headers, follow_redirects=False)\n\n        # Check the response\n        if response.status_code == 200:\n            json_data = response.json()\n            if not json_data:\n                raise GithubNoDataError(\n                    \"get_github_repo_content\",\n                    {\"github_url\": url, \"api_url\": api_url},\n                )\n            else:\n                # Remove unnecessary data from the response\n                # this will leave us with {name, path, size, html_url, download_url, type}\n                # html url is the url to view the file in the browser\n                # download url is the url to see just the raw file contents\n                for item in json_data:\n                    item.pop(\"sha\", None)\n                    item.pop(\"url\", None)\n                    item.pop(\"git_url\", None)\n                    item.pop(\"_links\", None)\n\n                return json_data\n        else:\n            if response.status_code == 404:\n                raise GithubNoDataError(\n                    \"get_github_repo_content\",\n                    {\"github_url\": url, \"api_url\": api_url},\n                )\n            if response.status_code == 403:\n                error_message = f\"GitHub API returned 403: {response.text}\"\n                if \"rate_limit\" in response.text:\n                    error_message = f\"GitHub API rate limit exceeded: {response.text}\"\n                raise Github404Error(\n                    \"get_github_repo_content\",\n                    {\"github_url\": url, \"api_url\": api_url},\n                    error_message,\n                )\n            else:\n                raise GithubError(\n                    \"get_github_repo_content\",\n                    {\"url\": url, \"status_code\": response.status_code},\n                    \"Error with client response\",\n                )\n    except httpx.RequestError as exc:\n        raise ImportSourceUrlHttpError(\n            \"get_github_repo_content\",\n            {\"url\": url},\n            \"Error while attempting to set up request url & headers\",\n            500,\n            exc,\n        )\n    except Exception as exc:\n        raise ImportSourceUrlError(\n            \"get_github_repo_content\",\n            {\"url\": url},\n            \"Error when reading GitHub content\",\n            500,\n            exc,\n        )\n\n\nasync def get_repo_tree(file_content, owner, repo) -> dict:\n    \"\"\"Parses GitHub content and returns a dictionary of directories and files\n\n    Parameters:\n        file_content {list} -- List of dictionaries containing GitHub file content\n        owner {str} -- Owner of the GitHub repo\n        repo {str} -- Name of the GitHub repo\n\n    Returns:\n        dict -- Dictionary of directories and files\n    \"\"\"\n    try:\n        # Check that the file content is a list\n        if not file_content or not isinstance(file_content, list):\n            raise ImportSourceUrlError(\n                \"get_repo_tree\",\n                {},\n                \"Invalid file content format\",\n                404,\n            )\n\n        # Process directories\n        results = {}\n        directories: list = [item for item in file_content if item[\"type\"] == \"dir\"]\n        files: list = [item for item in file_content if item[\"type\"] == \"file\"]\n\n        for dir in directories:\n            dir_content = await get_github_repo_content(\"\", owner, repo, dir[\"path\"])\n            parsed_dir_content = await get_repo_tree(dir_content, owner, repo)\n            dir_name = dir[\"name\"]\n            results[dir_name] = parsed_dir_content\n\n        # Process files\n        top_files = []\n        for file in files:\n            top_files.append(file)\n        if top_files and len(top_files) > 0:\n            results[\"files\"] = top_files\n\n        return results\n    except Exception as exc:\n        raise ImportSourceUrlError(\n            \"get_repo_tree\",\n            {\"owner\": owner, \"repo\": repo},\n            \"Error when parsing GitHub content\",\n            500,\n            exc,\n        )\n\n\nasync def get_raw_data_from_github_url(url: str) -> str:\n    \"\"\"Read raw data from a URL.\n\n    Parameters:\n        url (str): URL to read from\n\n    Returns:\n        str: Raw data from URL\n    \"\"\"\n    try:\n        Log.info(f\"  Started   Proc.get_raw_data_from_github_url(): url - {url}\")\n        if not url.endswith(\".py\"):\n            raise ImportSourceUrlError(\n                \"get_raw_data_from_github_url\",\n                {\"url\": url},\n                \"URL is not a valid Python file\",\n                404,\n            )\n        client = httpx.AsyncClient()\n        response = await client.get(url)\n        if response.status_code == 200:\n            return response.text\n        else:\n            raise ImportSourceUrlError(\n                \"get_raw_data_from_github_url\",\n                {\"url\": url},\n                \"Could not read raw data from URL\",\n                404,\n            )\n    except Exception as exc:\n        raise ImportSourceUrlError(\n            \"get_raw_data_from_github_url\",\n            {\"url\": url},\n            \"Error when reading raw data from URL\",\n            500,\n            exc,\n        )\n    finally:\n        Log.info(f\"  Finished    Proc.get_raw_data_from_github_url()\")\n\n\nasync def get_raw_data_from_github_repo(url: str) -> str | dict:\n    \"\"\"Read raw data from a repo URL.\n\n    Parameters:\n        url (str): Repo URL to read from\n\n    Returns:\n        str | dict: Raw repo data from URL\n    \"\"\"\n    from pprint import pprint\n\n    try:\n        Log.info(f\"  Started    Proc.get_raw_data_from_github_repo(): url - {url}\")\n        if not url or url == \"\":\n            raise ImportSourceUrlError(\n                \"get_raw_data_from_github_repo\",\n                {\"url\": url},\n                \"URL is not a valid repo URL\",\n                404,\n            )\n\n        # Parse the URL\n        url_parts = url.split(\"/\")\n        if len(url_parts) < 5:\n            raise ValueError(f\"Invalid GitHub repo URL: {url}\")\n\n        # Get the owner and repo name\n        # url is in the format github.com/owner/repo and possibly /repo/\n        owner = url_parts[3]\n        repo = url_parts[4]\n        Log.info(f\"Owner: {owner}, Repo: {repo}, URL: {url}\")\n        # Call the recursive function to create the repo structure\n        repo_contents = await get_github_repo_content(url, owner, repo, \"\", True)\n        repo_tree = await get_repo_tree(repo_contents, owner, repo)\n        repo_raw_data, repo_size = await reduce_repo_structure(repo_tree)\n        repo_structure = {\n            \"owner\": owner,\n            \"repo\": repo,\n            \"size\": repo_size,\n            \"raw\": repo_raw_data,\n        }\n        # pprint(repo_structure)\n\n        return repo_structure\n    except Exception as exc:\n        raise ImportSourceUrlError(\n            \"get_raw_data_from_github_repo\",\n            {\"url\": url},\n            f\"Error when reading raw data from repo URL: {exc}\",\n            500,\n            exc,\n        )\n    finally:\n        Log.info(f\"  Finished    Proc.get_raw_data_from_github_repo()\")\n\n\nasync def reduce_repo_structure(repo_data: dict, repo_size: int = 0) -> tuple:\n    \"\"\"Go through the repo structure and reduce it to just needed content\n\n    Parameters:\n        repo_data {dict} -- Dictionary of directories and files\n        repo_size {int} -- Size of the repo in bytes\n\n    Returns:\n        tuple -- Tuple containing the reduced repo structure and the repo size\n    \"\"\"\n    try:\n        repo_structure = {}\n        # loop through the repo data\n        for key, value in repo_data.items():\n            # if key is files, then it's a list of files\n            if key == \"files\":\n                files = []\n                # loop through the files\n                for file in value:\n                    # add the file size to the repo size\n                    repo_size += file.get(\"size\", 0)\n                    # if the file is a python file, get the raw data\n                    if file[\"download_url\"]:\n                        if file[\"download_url\"].endswith(\".py\"):\n                            file_raw_data = await get_raw_data_from_github_url(\n                                file[\"download_url\"]\n                            )\n                            file[\"file_type\"] = \"python\"\n                        else:  # otherwise, just get the download url\n                            file_raw_data = file[\"download_url\"]\n                            file[\"file_type\"] = \"other\"\n                    file[\"raw\"] = file_raw_data\n                    # remove unnecessary data from the file\n                    file.pop(\"path\", None)\n                    file.pop(\"size\", None)\n                    file.pop(\"type\", None)\n                    file.pop(\"html_url\", None)\n                    file.pop(\"download_url\", None)\n                    # add the file to the list of files\n                    files.append(file)\n                repo_structure[key] = files\n            else:  # key is a directory\n                # recursively call this function to reduce the sub directory\n                sub_dir_structure, repo_size = await reduce_repo_structure(\n                    value, repo_size\n                )\n                repo_structure[key] = sub_dir_structure\n\n        # return the repo structure and the repo size\n        # pprint(repo_structure)\n        return (repo_structure, repo_size)\n    except Exception as exc:\n        raise ImportSourceUrlError(\n            \"reduce_repo_structure\",\n            {\"repo_data\": repo_data},\n            \"Error when reading raw data from repo URL\",\n            500,\n            exc,\n        )\n",
                    "size": 11877,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/github_service.py"
                  },
                  {
                    "name": "palette_service.py",
                    "raw": "import networkx as nx\n\nfrom models.plot_data import DefaultPalette\n\n########################   OLD CODE   ########################\n\n# this is the default palette in the package\n# when containerized, we'll be looking in the container's /app directory\n# can see DockerFile for more info\n\n\nclass Palette:\n    \"\"\"A class to manage the plotter palette.\"\"\"\n\n    def __init__(self, palette: dict = {}):\n        \"\"\"Initialize a palette.\n\n        Parameters:\n        -----------\n        palette : dict (optional) (default=None)\n            A dictionary containing the data of the palette to initialize.\n        \"\"\"\n        if palette and isinstance(palette, dict) and palette != {}:\n            self.palette: dict[str, dict] = palette\n        else:\n            self.palette: dict[str, dict] = DefaultPalette.dict()\n\n    def create_new_theme(\n        self,\n        node_type: str,\n        base: str,\n        label: str,\n        shape: str,\n        color: str,\n        size: float,\n        alpha: float,\n    ) -> dict:\n        \"\"\"Create a new theme with the specified parameters.\n\n        Parameters:\n        -----------\n        node_type : str\n            The type of node for which to create a new theme.\n        label : str\n            The label of the nodes in the new theme.\n        shape : str\n            The shape of the nodes in the new theme.\n        color : str\n            The color of the nodes in the new theme.\n        size : float\n            The size of the nodes in the new theme.\n        alpha : float\n            The alpha (transparency) value of the nodes in the new theme.\n\n        Returns:\n        --------\n        dict\n            The palette.\n        \"\"\"\n        _base: str = base\n\n        # check if node type already exists\n        if node_type in self.palette[\"bases\"].keys():\n            # update existing base for the node type\n            _base = self.palette[\"bases\"][node_type]\n        else:\n            # add new node type to palette\n            self.palette[\"bases\"][node_type] = _base\n\n        # save base attrs to palette file\n        self.palette[\"labels\"][_base] = label\n        self.palette[\"shapes\"][_base] = shape\n        self.palette[\"colors\"][_base] = color\n        self.palette[\"sizes\"][_base] = size\n        self.palette[\"alphas\"][_base] = alpha\n\n        # return the palette\n        return self.palette\n\n    def get_node_styles(self, type: str = \"\") -> dict:\n        \"\"\"Get the styles for all node types.\n\n        Parameters:\n        -----------\n        type : str (optional) (default=None)\n            If specified, only the style for the specified node type will be returned.\n\n        Returns:\n        --------\n        dict[node_type(str), styles(dict)]\n            A dictionary containing the styles for all node types, or a specfied type.\n        \"\"\"\n        if type:\n            _base = self.palette[\"bases\"][type]\n            return {\n                type: {\n                    \"base\": _base,\n                    \"label\": self.palette[\"labels\"][_base],\n                    \"shape\": self.palette[\"shapes\"][_base],\n                    \"color\": self.palette[\"colors\"][_base],\n                    \"size\": self.palette[\"sizes\"][_base],\n                    \"alpha\": self.palette[\"alphas\"][_base],\n                }\n            }\n        else:\n            styles = {}\n            for node_type in self.palette[\"bases\"].keys():\n                _base = self.palette[\"bases\"][node_type]\n                styles[node_type] = {\n                    \"base\": _base,\n                    \"label\": self.palette[\"labels\"][_base],\n                    \"shape\": self.palette[\"shapes\"][_base],\n                    \"color\": self.palette[\"colors\"][_base],\n                    \"size\": self.palette[\"sizes\"][_base],\n                    \"alpha\": self.palette[\"alphas\"][_base],\n                }\n            return styles\n\n    def get_palette_data(self) -> dict[str, dict]:\n        \"\"\"Get the data of the current palette.\n\n        Returns:\n        --------\n        dict\n            A dictionary containing the data of the current palette.\n        \"\"\"\n        return {\n            \"bases\": self.palette[\"bases\"],\n            \"labels\": self.palette[\"labels\"],\n            \"shapes\": self.palette[\"shapes\"],\n            \"colors\": self.palette[\"colors\"],\n            \"sizes\": self.palette[\"sizes\"],\n            \"alphas\": self.palette[\"alphas\"],\n        }\n\n\n# TOOD: this is temporary until we define more in palette.py\ndef apply_styles(graph: nx.DiGraph) -> nx.DiGraph:\n    node_styles = {\n        # \"interactive\": visitor.interactives,\n        # \"expression\": visitor.expressions,\n        \"function\": {\"color\": \"#99ff99\", \"shape\": \"rectangle\"},\n        \"asyncfunction\": {\"color\": \"#99ff99\", \"shape\": \"rectangle\"},\n        \"class\": {\"color\": \"#ff9999\", \"shape\": \"ellipse\"},\n        # \"return\": visitor.returns,\n        # \"delete\": visitor.deletes,\n        # \"assign\": visitor.assigns,\n        # \"typealias\": visitor.typealiases,\n        # \"augassign\": visitor.augassigns,\n        # \"annassign\": visitor.annassigns,\n        # \"forloop\": visitor.forloops,\n        # \"asyncforloop\": visitor.asyncforloops,\n        # \"whileloop\": visitor.whileloops,\n        # \"if\": visitor.ifs,\n        # \"with\": visitor.withs,\n        # \"asyncwith\": visitor.asyncwiths,\n        # \"match\": visitor.matches,\n        # \"raise\": visitor.raises,\n        # \"try\": visitor.trys,\n        # \"trystar\": visitor.trystars,\n        # \"assert\": visitor.asserts,\n        \"import\": {\"color\": \"#9999ff\", \"shape\": \"diamond\"},\n        \"importfrom\": {\"color\": \"#9999ff\", \"shape\": \"diamond\"},\n        # \"global\": visitor.globals,\n        # \"nonlocal\": visitor.nonlocals,\n        # \"expr\": visitor.exprs,\n        # \"pass\": visitor.passes,\n        # \"break\": visitor.breaks,\n        # \"continue\": visitor.continues,\n        # \"boolop\": visitor.boolops,\n        # \"namedexpr\": visitor.namedexprs,\n        # \"binop\": visitor.binops,\n        # \"unaryop\": visitor.uarynops,\n        # \"lambda\": visitor.lambdas,\n        # \"ifexp\": visitor.ifexps,\n        # \"dict\": visitor.dicts,\n        # \"set\": visitor.sets,\n        # \"listcomp\": visitor.listcomps,\n        # \"setcomp\": visitor.setcomps,\n        # \"dictcomp\": visitor.dictcomps,\n        # \"generatorexp\": visitor.generatorexps,\n        # \"await\": visitor.awaits,\n        # \"yield\": visitor.yields,\n        # \"yieldfrom\": visitor.yieldfroms,\n        # \"comparison\": visitor.comparisons,\n        # \"call\": visitor.calls,\n        # \"formattedvalue\": visitor.formattedvalues,\n        # \"joinedstr\": visitor.joinedstrs,\n        # \"constant\": visitor.constats,\n        # \"attribute\": visitor.attribuetes,\n        # \"subscript\": visitor.subscripts,\n        # \"starred\": visitor.starreds,\n        # \"name\": visitor.names,\n        # \"list\": visitor.lists,\n        # \"tuple\": visitor.tuples,\n        # \"slice\": visitor.slices,\n        # \"load\": visitor.loads,\n        # \"store\": visitor.stores,\n        # \"del\": visitor.dels,\n        # \"and\": visitor.ands,\n        # \"or\": visitor.ors,\n        # \"add\": visitor.adds,\n        # \"sub\": visitor.subs,\n        # \"mult\": visitor.mults,\n        # \"matmult\": visitor.matmults,\n        # \"div\": visitor.divs,\n        # \"mod\": visitor.mods,\n        # \"pow\": visitor.pows,\n        # \"lshift\": visitor.lshifts,\n        # \"rshift\": visitor.rshifts,\n        # \"bitor\": visitor.bitors,\n        # \"bitxor\": visitor.bitxors,\n        # \"bitand\": visitor.bitands,\n        # \"floordiv\": visitor.floordivs,\n        # \"invert\": visitor.inverts,\n        # \"not\": visitor.nots,\n        # \"uadd\": visitor.uaddss,\n        # \"usub\": visitor.usubss,\n        # \"eq\": visitor.eqss,\n        # \"not_eq\": visitor.not_eqss,\n        # \"lt\": visitor.lts,\n        # \"lte\": visitor.ltes,\n        # \"gt\": visitor.gts,\n        # \"gte\": visitor.gtes,\n        # \"is\": visitor.iss,\n        # \"isnot\": visitor.isnots,\n        # \"in\": visitor.ins,\n        # \"notin\": visitor.notins,\n        # \"excepthandler\": visitor.excepthandlers,\n        # \"matchvalue\": visitor.matchvalues,\n        # \"matchsingleton\": visitor.matchsingleton,\n        # \"matchsequence\": visitor.matchsequences,\n        # \"matchmapping\": visitor.matchmappings,\n        # \"matchclass\": visitor.matchclasses,\n        # \"matchstar\": visitor.matchstars,\n        # \"matchas\": visitor.matchases,\n        # \"machor\": visitor.machors,\n        # \"typeignore\": visitor.typeignores,\n        # \"typevar\": visitor.typevars,\n        # \"paramspec\": visitor.paramspecs,\n        # \"typevartuple\": visitor.typevartuples,\n        # \"relation\": visitor.relations,\n        \"variables\": {\"color\": \"#009999\", \"shape\": \"rectangle\"},\n        \"module\": {\"color\": \"#ffff99\", \"shape\": \"rectangle\"},\n        \"default\": {\"color\": \"#0c0c44\", \"shape\": \"circle\"},\n    }\n\n    edge_styles = {\n        \"inheritance\": {\"color\": \"#990066\", \"line_style\": \"solid\"},\n        \"import\": {\"color\": \"#005500\", \"line_style\": \"dashed\"},\n        \"variable\": {\"color\": \"#000055\", \"line_style\": \"dotted\"},\n        \"function\": {\"color\": \"#550000\", \"line_style\": \"dotted\"},\n        \"default\": {\"color\": \"#000000\", \"line_style\": \"dotted\"},\n    }\n\n    for _, data in graph.nodes(data=True):\n        node_type = data.get(\"type\", \"default\")\n        style = node_styles.get(node_type.lower(), node_styles[\"default\"])\n        data.update(style)\n        data[\"opacity\"] = 0.5\n\n    for _, _, data in graph.edges(data=True):\n        edge_type = data.get(\"type\", \"default\")\n        style = edge_styles.get(edge_type, edge_styles[\"default\"])\n        data.update(style)\n\n    return graph\n",
                    "size": 9503,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/palette_service.py"
                  },
                  {
                    "name": "parser_service.py",
                    "raw": "import ast\n\nfrom networkx import DiGraph\nfrom models.graph_data import Node, Edge, GraphBuilder\nfrom models.source_data import Folder, File, SourceData\nfrom random import randint\nfrom services.ASTs.base_ast import BaseASTVisitor\n\n\nclass ParserService:\n    def __init__(\n        self, visitor: BaseASTVisitor, graph_builder: GraphBuilder = GraphBuilder()\n    ):\n        self.visitor = visitor\n        self.graph_builder = graph_builder\n        self.module_list = []\n\n    def parse(self, source: SourceData) -> DiGraph:\n        \"\"\"Parse the source code to a graph.\n\n        Parameters:\n        -----------\n        source: SourceData\n            The source code data to parse.\n\n        Returns:\n        --------\n        DiGraph\n            The parsed graph.\n        \"\"\"\n        # Set the current parent to the source name\n        self.current_parent = id(source.name)\n\n        # Add the source name to the module list\n        self.module_list.append(source.name)\n\n        # Parse the Python code to AST\n        if isinstance(source.source[0], File):\n            parsed_ast = self.parse_py_to_ast(source.source[0].raw)\n            self.visitor.generic_visit(parsed_ast)\n\n        return self.create_graph()\n\n    def parse_py_to_ast(self, python_code: str):\n        return ast.parse(python_code)\n\n    def create_graph(self) -> DiGraph:\n        try:\n            # Define types and corresponding attributes\n            node_types = {\n                \"interactive\": self.visitor.interactives,\n                \"expression\": self.visitor.expressions,\n                \"function\": self.visitor.functions,\n                \"asyncfunction\": self.visitor.asyncfunctions,\n                \"class\": self.visitor.classes,\n                \"return\": self.visitor.returns,\n                \"delete\": self.visitor.deletes,\n                \"assign\": self.visitor.assigns,\n                \"typealias\": self.visitor.typealiases,\n                \"augassign\": self.visitor.augassigns,\n                \"annassign\": self.visitor.annassigns,\n                \"forloop\": self.visitor.forloops,\n                \"asyncforloop\": self.visitor.asyncforloops,\n                \"whileloop\": self.visitor.whileloops,\n                \"if\": self.visitor.ifs,\n                \"with\": self.visitor.withs,\n                \"asyncwith\": self.visitor.asyncwiths,\n                \"match\": self.visitor.matches,\n                \"raise\": self.visitor.raises,\n                \"try\": self.visitor.trys,\n                \"trystar\": self.visitor.trystars,\n                \"assert\": self.visitor.asserts,\n                \"import\": self.visitor.imports,\n                \"importfrom\": self.visitor.importfroms,\n                \"global\": self.visitor.globals,\n                \"nonlocal\": self.visitor.nonlocals,\n                \"expr\": self.visitor.exprs,\n                \"pass\": self.visitor.passes,\n                \"break\": self.visitor.breaks,\n                \"continue\": self.visitor.continues,\n                \"boolop\": self.visitor.boolops,\n                \"namedexpr\": self.visitor.namedexprs,\n                \"binop\": self.visitor.binops,\n                \"unaryop\": self.visitor.uarynops,\n                \"lambda\": self.visitor.lambdas,\n                \"ifexp\": self.visitor.ifexps,\n                \"dict\": self.visitor.dicts,\n                \"set\": self.visitor.sets,\n                \"listcomp\": self.visitor.listcomps,\n                \"setcomp\": self.visitor.setcomps,\n                \"dictcomp\": self.visitor.dictcomps,\n                \"generatorexp\": self.visitor.generatorexps,\n                \"await\": self.visitor.awaits,\n                \"yield\": self.visitor.yields,\n                \"yieldfrom\": self.visitor.yieldfroms,\n                \"comparison\": self.visitor.comparisons,\n                \"call\": self.visitor.calls,\n                \"formattedvalue\": self.visitor.formattedvalues,\n                \"joinedstr\": self.visitor.joinedstrs,\n                \"constant\": self.visitor.constats,\n                \"attribute\": self.visitor.attribuetes,\n                \"subscript\": self.visitor.subscripts,\n                \"starred\": self.visitor.starreds,\n                \"name\": self.visitor.names,\n                \"list\": self.visitor.lists,\n                \"tuple\": self.visitor.tuples,\n                \"slice\": self.visitor.slices,\n                \"load\": self.visitor.loads,\n                \"store\": self.visitor.stores,\n                \"del\": self.visitor.dels,\n                \"and\": self.visitor.ands,\n                \"or\": self.visitor.ors,\n                \"add\": self.visitor.adds,\n                \"sub\": self.visitor.subs,\n                \"mult\": self.visitor.mults,\n                \"matmult\": self.visitor.matmults,\n                \"div\": self.visitor.divs,\n                \"mod\": self.visitor.mods,\n                \"pow\": self.visitor.pows,\n                \"lshift\": self.visitor.lshifts,\n                \"rshift\": self.visitor.rshifts,\n                \"bitor\": self.visitor.bitors,\n                \"bitxor\": self.visitor.bitxors,\n                \"bitand\": self.visitor.bitands,\n                \"floordiv\": self.visitor.floordivs,\n                \"invert\": self.visitor.inverts,\n                \"not\": self.visitor.nots,\n                \"uadd\": self.visitor.uaddss,\n                \"usub\": self.visitor.usubss,\n                \"eq\": self.visitor.eqss,\n                \"not_eq\": self.visitor.not_eqss,\n                \"lt\": self.visitor.lts,\n                \"lte\": self.visitor.ltes,\n                \"gt\": self.visitor.gts,\n                \"gte\": self.visitor.gtes,\n                \"is\": self.visitor.iss,\n                \"isnot\": self.visitor.isnots,\n                \"in\": self.visitor.ins,\n                \"notin\": self.visitor.notins,\n                \"excepthandler\": self.visitor.excepthandlers,\n                \"matchvalue\": self.visitor.matchvalues,\n                \"matchsingleton\": self.visitor.matchsingleton,\n                \"matchsequence\": self.visitor.matchsequences,\n                \"matchmapping\": self.visitor.matchmappings,\n                \"matchclass\": self.visitor.matchclasses,\n                \"matchstar\": self.visitor.matchstars,\n                \"matchas\": self.visitor.matchases,\n                \"machor\": self.visitor.machors,\n                \"typeignore\": self.visitor.typeignores,\n                \"typevar\": self.visitor.typevars,\n                \"paramspec\": self.visitor.paramspecs,\n                \"typevartuple\": self.visitor.typevartuples,\n                \"relation\": self.visitor.relations,\n                \"variables\": self.visitor.variables,\n            }\n\n            # Add nodes and edges to the graph\n            graph = DiGraph()\n            ast_with_names = [\"function\", \"class\", \"import\", \"variables\"]\n            for node_type, nodes in node_types.items():\n                for node in nodes:\n                    # if node in ast_with_names, set label to the name of the node\n                    if node_type in ast_with_names:\n                        node_label = str(node)\n                    else:\n                        node_label = node_type\n\n                    # need to pull out relavent info from the node\n                    self.create_node(\n                        graph=graph,\n                        node_id=id(str(node)),\n                        node_type=node_type,\n                        node_label=node_label,\n                        node_parent_id=id(self.current_parent),\n                    )\n                    # add the edge to the parent\n                    graph.add_edge(id(self.current_parent), id(str(node)))\n\n            return graph\n        except Exception as ex:\n            print(f\"Failed to add to graph: {ex}\")\n            raise ex\n\n    def create_node(\n        self,\n        graph: DiGraph,\n        node_id: int,\n        node_type: str,\n        node_label: str,\n        node_parent_id: int | None,\n    ):\n        # Check params\n        if not node_label or node_label == \"\":\n            node_label = f\"{node_type} (u)\"\n\n        # Add the node\n        graph.add_node(\n            node_id,\n            type=node_type,\n            label=f\"{node_label}: {node_type}\",\n            parent=node_parent_id,\n        )\n        # Add the edge\n        graph.add_edge(node_parent_id, node_id)\n\n    # def parse(self, source_data: SourceData):\n    #     for item in source_data.source:\n    #         if isinstance(item, File):\n    #             self._parse_file(item)\n    #         elif isinstance(item, Folder):\n    #             self._parse_folder(item)\n    #         else:\n    #             raise ValueError(\"Unsupported source type\")\n    #     return self.graph_builder.get_graph()\n\n    # def _parse_file(self, file: File):\n    #     parsed_ast = self.parse_py_to_ast(file.raw)\n    #     module = self.visitor.visit(parsed_ast)\n    #     self.build_graph(module, file.name)\n\n    # def _parse_folder(self, folder: Folder):\n    #     for file in folder.files:\n    #         self._parse_file(file)\n    #     for sub_folder in folder.folders:\n    #         self._parse_folder(sub_folder)\n\n    # def build_graph(self, module: dict, source_name: str):\n    #     for node_type, nodes in module.items():\n    #         for node in nodes:\n    #             node_label = (\n    #                 str(node)\n    #                 if node_type in [\"function\", \"class\", \"import\"]\n    #                 else node_type\n    #             )\n    #             self.graph_builder.add_node(\n    #                 Node(\n    #                     id=id(node),\n    #                     type=node_type,\n    #                     label=node_label,\n    #                     parent=id(source_name),\n    #                 )\n    #             )\n    #             self.graph_builder.add_edge(\n    #                 Edge(\n    #                     id=randint(0, 1000),\n    #                     source=id(source_name),\n    #                     target=id(node),\n    #                 )\n    #             )\n",
                    "size": 9898,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/parser_service.py"
                  },
                  {
                    "name": "plotter_service.py",
                    "raw": "from models.graph_data import GraphBase\nfrom models.plot_data import PlotOptions, Palette, RawData\n\n\nclass PlotterService:\n    @staticmethod\n    def plot_raw(graph: RawData, palette: Palette, options: PlotOptions):\n        return\n\n    @staticmethod\n    def plot_graph(graph: GraphBase, palette: Palette, options: PlotOptions):\n        return \"plotting\"\n",
                    "size": 353,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/plotter_service.py"
                  },
                  {
                    "name": "polygraph_service.py",
                    "raw": "from models.graph_data import GraphBase\nimport networkx as nx\nfrom typing import Dict\n\n\nclass PolygraphService:\n    @staticmethod\n    async def json_to_graph(json_graph: Dict) -> GraphBase:\n        # TODO: Flesh this out a bit more\n        ntxGraph = nx.node_link_graph(json_graph)\n        graphBase = GraphBase()\n        graphBase.graph = ntxGraph\n        return graphBase\n\n\n########################   OLD CODE   ########################\ndef graph_to_json_file(graph: nx.DiGraph, json_path: str) -> dict:\n    \"\"\"Converts a networkx graph to a JSON object.\n\n    Parameters:\n    -----------\n        graph (graphBase): The graph to convert.\n        json_path (str): The path to save the JSON file to.\n\n    Returns:\n    --------\n        dict: The JSON object.\n    \"\"\"\n    # Validate inputs\n    if graph is None:\n        raise ValueError(\"No graph provided.\")\n    if json_path is None or json_path == \"\":\n        raise ValueError(\"No json_path provided.\")\n\n    # Convert the graph to a JSON object and save it to a file\n    json_data = graph_to_json_data(graph)\n    return json_data\n\n\ndef json_file_to_graph(json_file: str) -> nx.DiGraph:\n    \"\"\"Converts a JSON object to a networkx graph.\n\n    Parameters:\n    -----------\n        json_file (str): The path to the JSON file to load.\n\n    Returns:\n    --------\n        nx.DiGraph: The networkx graph.\n    \"\"\"\n    import os\n    import json\n\n    # Validate inputs\n    if json_file is None or json_file == \"\":\n        raise ValueError(\"No json_file provided.\")\n\n    # Check if file exists\n    if not os.path.exists(json_file):\n        print(f\"File {json_file} not found.\")\n        raise FileNotFoundError(f\"File not found: {json_file}\")\n\n    # Load the JSON file and convert it to a graph\n    try:\n        with open(json_file, \"r\") as f:\n            graph_data = json.load(f)\n    except json.JSONDecodeError as e:\n        print(f\"Failed to load data from {json_file}.\")\n        raise e\n\n    return json_data_to_graph(graph_data)\n\n\ndef graph_to_json_data(nx_graph: nx.DiGraph) -> dict:\n    \"\"\"Converts a networkx graph to a JSON object.\n\n    Parameters:\n    -----------\n        nx_graph (nx.DiGraph): The graph to convert.\n\n    Returns:\n    --------\n        dict: The JSON object.\n    \"\"\"\n    from services.palette_service import Palette\n\n    # Create the JSON object\n    graph_data: dict[str, dict[str, dict[str, list]]] = {\"nodes\": {}, \"edges\": {}}\n\n    # Create all node objects\n    node_styles = Palette().get_node_styles()\n    for node_id, data in nx_graph.nodes.data(True):\n        node_type = data.get(\"type\", \"Unknown\")\n        if node_type not in node_styles.keys():\n            node_type = \"Unknown\"\n\n        node_obj = {\n            \"id\": node_id,\n            \"type\": node_type,\n            \"label\": data.get(\"label\", node_id),\n            \"base\": data.get(\"base\", \"unknown\"),\n            \"parent\": data.get(\"parent\"),\n            \"children\": [],\n            \"edges\": [],\n        }\n        graph_data[\"nodes\"][node_id] = node_obj\n\n    # Link parent and child nodes together\n    for node_id, node_obj in graph_data[\"nodes\"].items():\n        parent_id = node_obj[\"parent\"]\n        if parent_id and parent_id in graph_data[\"nodes\"]:\n            graph_data[\"nodes\"][parent_id][\"children\"].append(node_obj)\n\n    # Create edge objects and link them to their source nodes\n    for edge_id, (source, target) in enumerate(nx_graph.edges()):\n        if source not in graph_data[\"nodes\"] or target not in graph_data[\"nodes\"]:\n            continue\n        source_node: dict[str, list] = graph_data[\"nodes\"][source]\n        target_node: dict[str, list] = graph_data[\"nodes\"][target]\n\n        edge_obj = {\n            \"id\": str(edge_id),  # Convert edge_id to a string\n            \"type\": \"edge\",\n            \"source\": source_node[\"id\"],\n            \"target\": target_node[\"id\"],\n        }\n        graph_data[\"edges\"][str(edge_id)] = edge_obj  # Convert edge_id to a string\n        source_node[\"edges\"].append(edge_obj)\n\n    # # Clean out any graph_data[\"nodes\"] that have parents\n    # for node_id, node_obj in list(graph_data[\"nodes\"].items()):\n    #     if node_obj[\"parent\"]:\n    #         del graph_data[\"nodes\"][node_id]\n\n    return graph_data\n\n\ndef json_data_to_graph(json_data: dict[str, dict]) -> nx.DiGraph:\n    \"\"\"Converts a JSON object to a networkx graph.\n\n    Parameters:\n    -----------\n        json_data (dict): The JSON object to convert.\n\n    Returns:\n    --------\n        networkx.classes.graph.DiGraph: The graph.\n    \"\"\"\n\n    # Validate inputs\n    if json_data is None:\n        raise ValueError(\"No json provided.\")\n\n    # Create the graph\n    graph = nx.DiGraph()\n\n    def add_node_and_children(node_id, node_obj):\n        # Recursively add children\n        graph.add_node(\n            node_id,\n            type=node_obj[\"type\"],\n            label=node_obj[\"label\"],\n            base=node_obj[\"base\"],\n            parent=node_obj[\"parent\"],\n        )\n        for child_obj in node_obj[\"children\"]:\n            child_id = child_obj[\"id\"]\n            add_node_and_children(child_id, child_obj)\n\n    # Add nodes and their children to the graph\n    for node_id, node_obj in json_data[\"nodes\"].items():\n        add_node_and_children(node_id, node_obj)\n\n    # Add edges to the graph\n    for edge_id, edge_obj in json_data[\"edges\"].items():\n        graph.add_edge(edge_obj[\"source\"], edge_obj[\"target\"])\n\n    return graph\n\n\ndef graphbase_to_nx(graph_data: GraphBase) -> nx.DiGraph:\n    \"\"\"Converts a GraphBase object to a networkx graph.\n\n    Parameters:\n    -----------\n        graph_data (GraphBase): The GraphBase object to convert.\n\n    Returns:\n    --------\n        networkx.classes.graph.Graph: The graph.\n    \"\"\"\n\n    # Validate inputs\n    if graph_data is None:\n        raise ValueError(\"No graph provided.\")\n\n    # Create the graph\n    try:\n        G = nx.DiGraph()\n\n        # Add nodes to the graph\n        for node_id, node in graph_data.graph.nodes.items():\n            G.add_node(node_id, label=node.label, type=node.type, base=node.base)\n\n        # Add edges to the graph\n        for edge_id, edge in graph_data.graph.edges.items():\n            G.add_edge(edge.source, edge.target, id=edge_id, type=edge.type)\n\n        return G\n    except:\n        raise ValueError(\"'graph' must be formatted as a GraphBase object.\")\n\n\ndef nx_to_graphbase(digraph: nx.DiGraph) -> dict:\n    \"\"\"Converts a networkx DiGraph to a GraphBase compatible graph.\n\n    Parameters:\n    -----------\n        digraph (nx.DiGraph): The graph to convert.\n\n    Returns:\n    --------\n        dict: object compatible with graphbase database.\n    \"\"\"\n    from services.palette_service import Palette\n\n    # Validate inputs\n    if digraph is None:\n        raise ValueError(\"No graph provided.\")\n    if not isinstance(digraph, nx.DiGraph):\n        raise ValueError(\"'graph' must be formatted as a GraphBase object.\")\n\n    # Create the GraphBase object\n    graph_data: dict[str, list] = {\"nodes\": [], \"links\": []}\n\n    # Create all node objects\n    node_styles = Palette().get_node_styles()\n    for node_id, data in digraph.nodes.data(True):\n        node_type = data.get(\"type\", \"Unknown\")\n        if node_type not in node_styles.keys():\n            node_type = \"Unknown\"\n\n        node_obj = {\n            \"id\": node_id,\n            \"type\": node_type,\n            \"label\": data.get(\"label\", node_id),\n            \"base\": data.get(\"base\", \"unknown\"),\n            \"parent\": data.get(\"parent\"),\n            \"children\": [],\n            \"edges\": [],\n        }\n        graph_data[\"nodes\"].append(node_obj)\n\n    # Link parent and child nodes together\n    for node_obj in graph_data[\"nodes\"]:\n        parent_id = node_obj[\"parent\"]\n        if parent_id and parent_id in graph_data[\"nodes\"]:\n            parent_obj: dict = graph_data[\"nodes\"][parent_id]\n            parents_children: list = parent_obj[\"children\"]\n            if node_obj not in parents_children:\n                parents_children.append(node_obj)\n\n    # Create edge objects and link them to their source nodes\n    for edge_id, (source, target) in enumerate(digraph.edges()):\n        if source not in graph_data[\"nodes\"] or target not in graph_data[\"nodes\"]:\n            continue\n        source_node: dict[str, list] = graph_data[\"nodes\"][source]\n        target_node: dict[str, list] = graph_data[\"nodes\"][target]\n\n        edge_obj = {\n            \"id\": edge_id,\n            \"type\": \"edge\",\n            \"source\": source_node[\"id\"],\n            \"target\": target_node[\"id\"],\n        }\n        graph_data[\"links\"].append(edge_obj)\n        source_node[\"links\"].append(edge_obj)  # TODO: why was i doing this?\n\n    # # Clean out any graph_data[\"nodes\"] that have parents\n    # for node_id, node_obj in list(graph_data[\"nodes\"].items()):\n    #     if node_obj[\"parent\"]:\n    #         del graph_data[\"nodes\"][node_id]\n\n    return graph_data\n\n\ndef gJGF_to_nx(graph_name: str, graph_data: dict) -> tuple:\n    \"\"\"Convert a graph in gJGF format to a networkx graph.\n\n    Parameters:\n    -----------\n        graph_name (str):\n            The name of the graph.\n        graph_data (dict):\n            The graph in gJGF format.\n\n    Returns:\n    --------\n        tuple (nx.DiGraph, str):\n            The graph and the filename.\n    \"\"\"\n    from util.exceptions import PolyGraphError\n\n    # Convert the graph to a networkx graph\n    graph: nx.DiGraph = nx.node_link_graph(graph_data, directed=True, multigraph=False)\n\n    # Check if graph found\n    if not graph:\n        raise PolyGraphError(\n            \"gJGF_to_nxGraph\",\n            \"Graph not provided\",\n            {\"graph_name\": graph_name, \"graph\": graph},\n        )\n    elif graph.number_of_nodes() == 0:\n        raise PolyGraphError(\n            \"gJGF_to_nxGraph\",\n            {\"graph_name\": graph_name, \"graph\": graph},\n            \"Graph has no nodes\",\n        )\n\n    # Return the graph\n    return graph, graph_name\n",
                    "size": 9844,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/polygraph_service.py"
                  },
                  {
                    "name": "position_service.py",
                    "raw": "from models.plot_data import LayoutType\nimport networkx as nx\nfrom typing import Callable\n\n\n########################   OLD CODE   ########################\nclass Positions:\n    def __init__(self, include_networkx: bool = True, include_custom: bool = True):\n        \"\"\"Constructor for Layouts\n\n        Parameters\n        ----------\n        layouts : tuple(str,function,list)\n            A tuple of layout_names, the layout_function, and their attributes\n        \"\"\"\n        self._layouts: list[LayoutType] = []\n        if include_networkx:\n            self.add_networkx_layouts()\n        if include_custom:\n            self.add_custom_layouts()\n\n    def add_layout(self, name: str, layout: Callable, attr: list) -> None:\n        \"\"\"Add a layout to the list of available layouts\n\n        Parameters\n        ----------\n        name : str\n            The name of the layout\n        layout : function\n            The layout function\n        attr : list\n            The attributes of the layout\n        \"\"\"\n        layoutType: LayoutType = LayoutType()\n        layoutType[\"name\"] = name\n        layoutType[\"func\"] = layout\n        layoutType[\"params\"] = attr\n        self._layouts.append(layoutType)\n\n    def add_networkx_layouts(self) -> None:\n        \"\"\"Add all networkx layouts to the list of available layouts\"\"\"\n        self.add_layout(\n            \"spring_layout\",\n            nx.layout.spring_layout,\n            [\"graph\", \"seed\"],\n        )\n        self.add_layout(\"spiral_layout\", nx.layout.spiral_layout, [\"graph\"])\n        self.add_layout(\"circular_layout\", nx.layout.circular_layout, [\"graph\"])\n        self.add_layout(\"random_layout\", nx.layout.random_layout, [\"graph\", \"seed\"])\n        self.add_layout(\"spectral_layout\", nx.layout.spectral_layout, [\"graph\"])\n        self.add_layout(\"shell_layout\", nx.layout.shell_layout, [\"graph\", \"nshells\"])\n        # self.add_layout(\"planar_layout\", nx.layout.planar_layout, [\"graph\"])\n\n    def add_custom_layouts(self) -> None:\n        \"\"\"Add all custom layouts to the list of available layouts\"\"\"\n        from models.custom_layouts.sorted_square_layout import sorted_square_layout\n\n        self.add_layout(\"sorted_square_layout\", sorted_square_layout, [\"graph\"])\n\n        # from .custom_layouts.cluster_layout import cluster_layout\n        # self.add_layout(\"cluster_layout\", cluster_layout, [\"graph\", \"root\"])\n\n    def get_layout_names(self) -> list:\n        \"\"\"Get all layout names from the list of available layouts\n\n        Returns\n        -------\n        list\n            The name of available layouts\n        \"\"\"\n        return [layout[\"name\"] for layout in self._layouts]\n\n    def get_layouts(self) -> list:\n        \"\"\"Get all layouts with their attributes from the list of available layouts\n\n        Returns\n        -------\n        list[LayoutType]:\n            The layouts with their attributes\n        \"\"\"\n        return self._layouts\n\n    def get_layout(self, name: str) -> LayoutType:\n        \"\"\"Get a layout from the list of available layouts\n\n        Parameters\n        ----------\n        name : str\n            The name of the layout\n\n        Returns\n        -------\n        dict (LayoutType):\n            The layout with its attributes\n        \"\"\"\n        # Check if the provided name in list (_layouts: list[LayoutType])\n        for layout in self._layouts:\n            if layout[\"name\"] == name:\n                return layout\n        # if here then layout not found\n        raise ValueError(f\"Layout {name} does not exist\")\n\n    def get_layout_params(self, name: str) -> list:\n        \"\"\"Get the parameters of a layout from the list of available layouts\n\n        Parameters\n        ----------\n        name : str\n            The name of the layout\n\n        Returns\n        -------\n        list\n            The parameters of the layout\n        \"\"\"\n        # Check if the provided name in list (_layouts: list[LayoutType])\n        for layout in self._layouts:\n            if layout[\"name\"] == name:\n                return layout[\"params\"]\n\n        # if here then layout not found\n        raise ValueError(f\"Layout {name} does not exist\")\n\n    def get_positions(self, name: str, seed: int = -1, **kwargs) -> dict:\n        \"\"\"Get a positions from the list of available layouts\n\n        Parameters\n        ----------\n        name : str\n            The name of the layout\n        seed : int (optional, default=-1)\n            The seed to use for the layout\n        **kwargs : dict\n            The attributes of the layout\n\n        Returns\n        -------\n        dict\n            The positions of the layout\n        \"\"\"\n        _graph: nx.Graph = kwargs.get(\"G\", None)\n        # get the layout function\n        layout_func: Callable\n        layout_params: list\n        for layout in self._layouts:\n            if layout[\"name\"] == name:\n                layout_func = layout[\"func\"]\n                layout_params = layout[\"params\"]\n                break\n        layout_kwargs: dict = {}\n        for param in layout_params:\n            if param == \"seed\" and seed != -1:\n                # Set the seed if it is not -1\n                layout_kwargs[\"seed\"] = seed\n            elif param == \"nshells\" and name == \"shell_layout\":\n                # Group nodes by parent\n                if \"G\" not in kwargs:\n                    grouped_nodes: dict[str, list] = {}\n                    for node, data in kwargs[\"G\"].nodes(data=True):\n                        parent = data.get(\"parent\", \"Unknown\")\n                        if parent not in grouped_nodes:\n                            grouped_nodes[parent] = []\n                        grouped_nodes[parent].append(node)\n                    # Create the list of lists (shells)\n                    shells = list(grouped_nodes.values())\n                    layout_kwargs[\"nshells\"] = shells\n            elif param == \"root\" and name == \"cluster_layout\":\n                # Set the root node\n                layout_kwargs[\"root\"] = kwargs[\"root\"]\n            elif param != \"G\":\n                # TODO Handle other parameters here\n                pass\n        return layout_func(G=_graph, **layout_kwargs)\n\n    def get_node_positions(self, graph: nx.DiGraph, layout_name: str) -> dict:\n        \"\"\"Gets the node positions for a given layout.\n\n        Parameters:\n        -----------\n            graph (nx.DiGraph):\n                The graph to plot.\n            layout_name (str):\n                The name of the layout.\n\n        Returns:\n        --------\n            positions (dict):\n                The positions of nodes for layout.\n        \"\"\"\n        seed = -1\n        layout_params = self.get_layout_params(layout_name)\n        layout_kwargs: dict = {\"G\": graph}\n        for param in layout_params:\n            if param == \"seed\":\n                import random\n\n                seed = random.randint(0, 1000)\n                layout_kwargs[\"seed\"] = seed\n            elif param == \"nshells\" and layout_name == \"shell_layout\":\n                # Group nodes by parent\n                grouped_nodes: dict[str, list] = {}\n                for node, data in graph.nodes(data=True):\n                    parent = data.get(\"parent\", \"Unknown\")\n                    if parent not in grouped_nodes:\n                        grouped_nodes[parent] = []\n                    grouped_nodes[parent].append(node)\n                # Create the list of lists (shells)\n                shells = list(grouped_nodes.values())\n                layout_kwargs[\"nshells\"] = shells\n            elif param == \"root\" and layout_name == \"cluster_layout\":\n                # get the node at the very top\n                root = None\n                for node, data in graph.nodes(data=True):\n                    if data.get(\"label\", \"\") == \"root\":\n                        root = node\n                        break\n                layout_kwargs[\"root\"] = root\n            elif param != \"G\":\n                # TODO: Handle other parameters here\n                pass\n\n        # Compute layout positions\n        pos: dict = self.get_positions(layout_name, **layout_kwargs)\n        return pos\n",
                    "size": 8045,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/position_service.py"
                  }
                ],
                "folders": [
                  {
                    "files": [
                      {
                        "name": "__init__.py",
                        "raw": "",
                        "size": 0,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/ASTs/__init__.py"
                      },
                      {
                        "name": "base_ast.py",
                        "raw": "import ast\nfrom abc import abstractmethod\n\n\nclass ASTVisitor(ast.NodeVisitor):\n    @abstractmethod\n    def visit(self, node) -> ast.AST:\n        pass\n\n\nclass BaseASTVisitor(ast.NodeVisitor):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        \"\"\"The base AST visitor.\"\"\"\n        self.module = ast.AST\n        # region AST objects\n        self.module = ast.AST\n        # define the type of list List<AST>\n        self.variables: list[ast.AST] = []\n        self.interactives: list[ast.AST] = []\n        self.expressions: list[ast.AST] = []\n        self.functiontypes: list[ast.AST] = []\n        self.functions: list[ast.AST] = []\n        self.asyncfunctions: list[ast.AST] = []\n        self.classes: list[ast.AST] = []\n        self.returns: list[ast.AST] = []\n        self.deletes: list[ast.AST] = []\n        self.assigns: list[ast.AST] = []\n        self.typealiases: list[ast.AST] = []\n        self.augassigns: list[ast.AST] = []\n        self.annassigns: list[ast.AST] = []\n        self.forloops: list[ast.AST] = []\n        self.asyncforloops: list[ast.AST] = []\n        self.whileloops: list[ast.AST] = []\n        self.ifs: list[ast.AST] = []\n        self.withs: list[ast.AST] = []\n        self.asyncwiths: list[ast.AST] = []\n        self.matches: list[ast.AST] = []\n        self.raises: list[ast.AST] = []\n        self.trys: list[ast.AST] = []\n        self.trystars: list[ast.AST] = []\n        self.asserts: list[ast.AST] = []\n        self.imports: list[ast.AST] = []\n        self.importfroms: list[ast.AST] = []\n        self.globals: list[ast.AST] = []\n        self.nonlocals: list[ast.AST] = []\n        self.exprs: list[ast.AST] = []\n        self.passes: list[ast.AST] = []\n        self.breaks: list[ast.AST] = []\n        self.continues: list[ast.AST] = []\n        self.boolops: list[ast.AST] = []\n        self.namedexprs: list[ast.AST] = []\n        self.binops: list[ast.AST] = []\n        self.uarynops: list[ast.AST] = []\n        self.lambdas: list[ast.AST] = []\n        self.ifexps: list[ast.AST] = []\n        self.dicts: list[ast.AST] = []\n        self.sets: list[ast.AST] = []\n        self.listcomps: list[ast.AST] = []\n        self.setcomps: list[ast.AST] = []\n        self.dictcomps: list[ast.AST] = []\n        self.generatorexps: list[ast.AST] = []\n        self.awaits: list[ast.AST] = []\n        self.yields: list[ast.AST] = []\n        self.yieldfroms: list[ast.AST] = []\n        self.comparisons: list[ast.AST] = []\n        self.calls: list[ast.AST] = []\n        self.formattedvalues: list[ast.AST] = []\n        self.joinedstrs: list[ast.AST] = []\n        self.constats: list[ast.AST] = []\n        self.attribuetes: list[ast.AST] = []\n        self.subscripts: list[ast.AST] = []\n        self.starreds: list[ast.AST] = []\n        self.names: list[ast.AST] = []\n        self.lists: list[ast.AST] = []\n        self.tuples: list[ast.AST] = []\n        self.slices: list[ast.AST] = []\n        self.loads: list[ast.AST] = []\n        self.stores: list[ast.AST] = []\n        self.dels: list[ast.AST] = []\n        self.ands: list[ast.AST] = []\n        self.ors: list[ast.AST] = []\n        self.adds: list[ast.AST] = []\n        self.subs: list[ast.AST] = []\n        self.mults: list[ast.AST] = []\n        self.matmults: list[ast.AST] = []\n        self.divs: list[ast.AST] = []\n        self.mods: list[ast.AST] = []\n        self.pows: list[ast.AST] = []\n        self.lshifts: list[ast.AST] = []\n        self.rshifts: list[ast.AST] = []\n        self.bitors: list[ast.AST] = []\n        self.bitxors: list[ast.AST] = []\n        self.bitands: list[ast.AST] = []\n        self.floordivs: list[ast.AST] = []\n        self.inverts: list[ast.AST] = []\n        self.nots: list[ast.AST] = []\n        self.uaddss: list[ast.AST] = []\n        self.usubss: list[ast.AST] = []\n        self.eqss: list[ast.AST] = []\n        self.not_eqss: list[ast.AST] = []\n        self.lts: list[ast.AST] = []\n        self.ltes: list[ast.AST] = []\n        self.gts: list[ast.AST] = []\n        self.gtes: list[ast.AST] = []\n        self.iss: list[ast.AST] = []\n        self.isnots: list[ast.AST] = []\n        self.ins: list[ast.AST] = []\n        self.notins: list[ast.AST] = []\n        self.excepthandlers: list[ast.AST] = []\n        self.matchvalues: list[ast.AST] = []\n        self.matchsingleton: list[ast.AST] = []\n        self.matchsequences: list[ast.AST] = []\n        self.matchmappings: list[ast.AST] = []\n        self.matchclasses: list[ast.AST] = []\n        self.matchstars: list[ast.AST] = []\n        self.matchases: list[ast.AST] = []\n        self.machors: list[ast.AST] = []\n        self.typeignores: list[ast.AST] = []\n        self.typevars: list[ast.AST] = []\n        self.paramspecs: list[ast.AST] = []\n        self.typevartuples: list[ast.AST] = []\n        self.relations: list[ast.AST] = []\n        # endregion\n\n    # def visit(self, node):\n    #     self.generic_visit(node)\n    #     return self.module\n",
                        "size": 4929,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/ASTs/base_ast.py"
                      },
                      {
                        "name": "python_ast.py",
                        "raw": "import ast\nfrom .base_ast import BaseASTVisitor\n\n\nclass PythonAST(BaseASTVisitor):\n    def __init__(self, module_list: list = [], *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.module_list = module_list\n\n    # region Visits\n\n    # region Mode\n    def visit_Expression(self, node):\n        self.generic_visit(node)\n        self.expressions.append(node)\n\n    def visit_FunctionType(self, node):\n        self.generic_visit(node)\n        self.functiontypes.append(node)\n\n    def visit_Interactive(self, node):\n        self.generic_visit(node)\n        self.interactives.append(node)\n\n    def visit_Module(self, node):\n        \"\"\"Visit the module node.\"\"\"\n        self.module = node\n        # see if the module is in the module list\n        # module list is a list of names of modules\n        if self.module and self.module_list:\n            self.generic_visit(node)\n\n    # endregion\n\n    # region Literals\n    def visit_Constant(self, node):\n        self.generic_visit(node)\n        self.constats.append(node)\n\n    def visit_Dict(self, node):\n        \"\"\"Visit the dict node.\"\"\"\n        self.generic_visit(node)\n        self.dicts.append(node)\n\n    def visit_FormattedValue(self, node):\n        self.generic_visit(node)\n        self.formattedvalues.append(node)\n\n    def visit_Invert(self, node):\n        self.generic_visit(node)\n        self.inverts.append(node)\n\n    def visit_JoinedStr(self, node):\n        self.generic_visit(node)\n        self.joinedstrs.append(node)\n\n    def visit_List(self, node):\n        \"\"\"Visit the list node.\"\"\"\n        self.generic_visit(node)\n        self.lists.append(node)\n\n    def visit_Set(self, node):\n        self.generic_visit(node)\n        self.sets.append(node)\n\n    def visit_Tuple(self, node):\n        self.generic_visit(node)\n        self.tuples.append(node)\n\n    def visit_UAdd(self, node):\n        self.generic_visit(node)\n        self.uaddss.append(node)\n\n    def visit_USub(self, node):\n        self.generic_visit(node)\n        self.usubss.append(node)\n\n    # endregion\n\n    # region Variables\n    def visit_Name(self, node):\n        self.generic_visit(node)\n        self.names.append(node)\n\n    def visit_Store(self, node):\n        self.generic_visit(node)\n        self.stores.append(node)\n\n    def visit_Starred(self, node):\n        self.generic_visit(node)\n        self.starreds.append(node)\n\n    def visit_arg(self, node: ast.arg):\n        self.generic_visit(node)\n        self.starreds.append(node)\n        pass\n        # \"\"\"Visit the arg node.\n\n        # Parameters:\n        # -----------\n        # node : ast.arg\n        #     The arg node to visit.\n\n        # Notes:\n        # ------\n        # In the following \"def some_func(x):\", the ast.arg node represents 'x'. \\n\n        # While ast.Name.id represents 'some_func'.\n        # \"\"\"\n\n        # # Add the arg node to the graph\n        # _type: str = None\n        # if self.current_type:\n        #     _type = self.current_type\n        # else:\n        #     _type = \"Variable\"\n        # self.create_new_node(\n        #     node_id=id(node),\n        #     node_type=_type,\n        #     node_label=node.arg,\n        #     node_parent_id=id(self.current_parent),\n        # )\n        # # Set the current parent to the arg node\n        # self.current_parent = node\n\n    # endregion\n\n    # region Expressions\n    def visit_Attribute(self, node):\n        self.generic_visit(node)\n        self.attribuetes.append(node)\n\n    def visit_BinOp(self, node):\n        self.generic_visit(node)\n        self.binops.append(node)\n\n    def visit_BoolOp(self, node):\n        self.generic_visit(node)\n        self.boolops.append(node)\n\n    def visit_Call(self, node):\n        self.generic_visit(node)\n        self.calls.append(node)\n\n    def visit_Compare(self, node):\n        self.generic_visit(node)\n        self.comparisons.append(node)\n\n    def visit_Expr(self, node):\n        self.generic_visit(node)\n        self.exprs.append(node)\n\n    def visit_IfExp(self, node):\n        self.generic_visit(node)\n        self.ifexps.append(node)\n\n    def visit_NamedExpr(self, node):\n        self.generic_visit(node)\n        self.namedexprs.append(node)\n\n    def visit_UnaryOp(self, node):\n        self.generic_visit(node)\n        self.uarynops.append(node)\n\n    # endregion\n\n    # region Expressions - Comprehensions\n    def visit_DictComp(self, node):\n        self.generic_visit(node)\n        self.dictcomps.append(node)\n\n    def visit_GeneratorExp(self, node):\n        self.generic_visit(node)\n        self.generatorexps.append(node)\n\n    def visit_ListComp(self, node):\n        self.generic_visit(node)\n        self.listcomps.append(node)\n\n    def visit_SetComp(self, node):\n        self.generic_visit(node)\n        self.setcomps.append(node)\n\n    # endregion\n\n    # region Expressions - Subscripting\n    def visit_Slice(self, node):\n        self.generic_visit(node)\n        self.slices.append(node)\n\n    def visit_Subscript(self, node):\n        self.generic_visit(node)\n        self.subscripts.append(node)\n\n    # endregion\n\n    # region Statements\n    def visit_AnnAssign(self, node):\n        self.generic_visit(node)\n        self.annassigns.append(node)\n\n    def visit_Assert(self, node):\n        self.generic_visit(node)\n        self.asserts.append(node)\n\n    def visit_Assign(self, node):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                self.variables.append(target.id)\n        self.generic_visit(node)\n\n    def visit_AugAssign(self, node):\n        self.generic_visit(node)\n        self.augassigns.append(node)\n\n    def visit_Delete(self, node):\n        self.generic_visit(node)\n        self.deletes.append(node)\n\n    def visit_Pass(self, node):\n        self.generic_visit(node)\n        self.passes.append(node)\n\n    def visit_Raise(self, node):\n        self.generic_visit(node)\n        self.raises.append(node)\n\n    # endregion\n\n    # region Statements - Imports\n    def visit_Import(self, node):\n        for alias in node.names:\n            self.imports.append(alias.name)\n        # see if any of the imports are in the module list\n        for module in self.module_list:\n            if module in self.imports:\n                self.relations.append((module, self.module))\n                self.generic_visit(node)\n\n    def visit_ImportFrom(self, node):\n        module = node.module\n        for alias in node.names:\n            self.imports.append(f\"{module}.{alias.name}\")\n        # see if any of the imports are in the module list\n        for module in self.module_list:\n            if module in self.imports:\n                self.relations.append((module, self.module))\n                self.generic_visit(node)\n\n    # endregion\n\n    # region Control Flow\n    def visit_Break(self, node):\n        self.generic_visit(node)\n        self.breaks.append(node)\n\n    def visit_Continue(self, node):\n        self.generic_visit(node)\n        self.continues.append(node)\n\n    def visit_ExceptHandler(self, node):\n        self.generic_visit(node)\n        self.excepthandlers.append(node)\n\n    def visit_For(self, node):\n        self.generic_visit(node)\n        self.forloops.append(node)\n\n    def visit_If(self, node):\n        self.generic_visit(node)\n        self.ifs.append(node)\n\n    def visit_Try(self, node):\n        self.generic_visit(node)\n        self.trys.append(node)\n\n    def visit_TryStar(self, node):\n        self.generic_visit(node)\n        self.trystars.append(node)\n\n    def visit_While(self, node):\n        self.generic_visit(node)\n        self.whileloops.append(node)\n\n    def visit_With(self, node):\n        self.generic_visit(node)\n        self.withs.append(node)\n\n    # endregion\n\n    # region Pattern Matching\n    def visit_Match(self, node):\n        self.generic_visit(node)\n        self.matches.append(node)\n\n    def visit_MatchAs(self, node):\n        self.generic_visit(node)\n        self.matchases.append(node)\n\n    def visit_MatchClass(self, node):\n        self.generic_visit(node)\n        self.matchclasses.append(node)\n\n    def visit_MatchMapping(self, node):\n        self.generic_visit(node)\n        self.matchmappings.append(node)\n\n    def visit_MatchOr(self, node):\n        self.generic_visit(node)\n        self.machors.append(node)\n\n    def visit_MatchSequence(self, node):\n        self.generic_visit(node)\n        self.matchsequences.append(node)\n\n    def visit_MatchSingleton(self, node):\n        self.generic_visit(node)\n        self.matchsingleton.append(node)\n\n    def visit_MatchStar(self, node):\n        self.generic_visit(node)\n        self.matchstars.append(node)\n\n    def visit_MatchValue(self, node):\n        self.generic_visit(node)\n        self.matchvalues.append(node)\n\n    # endregion\n\n    # region Functions and Class Definitions\n    def visit_ClassDef(self, node):\n        self.classes.append(node.name)\n        for base in node.bases:\n            if isinstance(base, ast.Name):\n                self.relations.append((base.id, node.name))\n        self.generic_visit(node)\n\n    def visit_FunctionDef(self, node):\n        self.functions.append(node.name)\n        self.generic_visit(node)\n\n    def visit_Global(self, node):\n        self.generic_visit(node)\n        self.globals.append(node)\n\n    def visit_Lambda(self, node):\n        self.generic_visit(node)\n        self.lambdas.append(node)\n\n    def visit_Nonlocal(self, node):\n        self.generic_visit(node)\n        self.nonlocals.append(node)\n\n    def visit_Return(self, node):\n        self.generic_visit(node)\n        self.returns.append(node)\n\n    def visit_Yield(self, node):\n        self.generic_visit(node)\n        self.yields.append(node)\n\n    def visit_YieldFrom(self, node):\n        self.generic_visit(node)\n        self.yieldfroms.append(node)\n\n    # endregion\n\n    # region Async and Await\n    def visit_AsyncFor(self, node):\n        self.generic_visit(node)\n        self.asyncforloops.append(node)\n\n    def visit_AsyncFunctionDef(self, node):\n        self.asyncfunctions.append(node.name)\n        self.generic_visit(node)\n\n    def visit_AsyncWith(self, node):\n        self.generic_visit(node)\n        self.asyncwiths.append(node)\n\n    def visit_Await(self, node):\n        self.generic_visit(node)\n        self.awaits.append(node)\n\n    # endregion\n\n    # region Other - String Comparisons\n    def visit_And(self, node):\n        self.generic_visit(node)\n        self.ands.append(node)\n\n    def visit_In(self, node):\n        self.generic_visit(node)\n        self.ins.append(node)\n\n    def visit_NotIn(self, node):\n        self.generic_visit(node)\n        self.notins.append(node)\n\n    def visit_Is(self, node):\n        self.generic_visit(node)\n        self.iss.append(node)\n\n    def visit_IsNot(self, node):\n        self.generic_visit(node)\n        self.isnots.append(node)\n\n    def visit_Not(self, node):\n        self.generic_visit(node)\n        self.nots.append(node)\n\n    def visit_Or(self, node):\n        self.generic_visit(node)\n        self.ors.append(node)\n\n    # endregion\n\n    # region Other - File Handling\n    def visit_Load(self, node):\n        self.generic_visit(node)\n        self.loads.append(node)\n\n    def visit_Del(self, node):\n        self.generic_visit(node)\n        self.dels.append(node)\n\n    # endregion\n\n    # region Other - Binary Operations\n    def visit_Add(self, node):\n        self.generic_visit(node)\n        self.adds.append(node)\n\n    def visit_BitAnd(self, node):\n        self.generic_visit(node)\n        self.bitands.append(node)\n\n    def visit_BitOr(self, node):\n        self.generic_visit(node)\n        self.bitors.append(node)\n\n    def visit_BitXor(self, node):\n        self.generic_visit(node)\n        self.bitxors.append(node)\n\n    def visit_FloorDiv(self, node):\n        self.generic_visit(node)\n        self.floordivs.append(node)\n\n    def visit_Div(self, node):\n        self.generic_visit(node)\n        self.divs.append(node)\n\n    def visit_LShift(self, node):\n        self.generic_visit(node)\n        self.lshifts.append(node)\n\n    def visit_MatMult(self, node):\n        self.generic_visit(node)\n        self.matmults.append(node)\n\n    def visit_Mod(self, node):\n        self.generic_visit(node)\n        self.mods.append(node)\n\n    def visit_Mult(self, node):\n        self.generic_visit(node)\n        self.mults.append(node)\n\n    def visit_Pow(self, node):\n        self.generic_visit(node)\n        self.pows.append(node)\n\n    def visit_RShift(self, node):\n        self.generic_visit(node)\n        self.rshifts.append(node)\n\n    def visit_Sub(self, node):\n        self.generic_visit(node)\n        self.subs.append(node)\n\n    # endregion\n\n    # region Other - Binary Comparisons\n    def visit_Eq(self, node):\n        self.generic_visit(node)\n        self.eqss.append(node)\n\n    def visit_NotEq(self, node):\n        self.generic_visit(node)\n        self.not_eqss.append(node)\n\n    def visit_Lt(self, node):\n        self.generic_visit(node)\n        self.lts.append(node)\n\n    def visit_LtE(self, node):\n        self.generic_visit(node)\n        self.ltes.append(node)\n\n    def visit_Gt(self, node):\n        self.generic_visit(node)\n        self.gts.append(node)\n\n    def visit_GtE(self, node):\n        self.generic_visit(node)\n        self.gtes.append(node)\n\n    # endregion\n\n    # region Other - Type Aliases\n    def visit_ParamSpec(self, node):\n        self.generic_visit(node)\n        self.paramspecs.append(node)\n\n    def visit_TypeIgnore(self, node):\n        self.generic_visit(node)\n        self.typeignores.append(node)\n\n    def visit_TypeVar(self, node):\n        self.generic_visit(node)\n        self.typevars.append(node)\n\n    def visit_TypeVarTuple(self, node):\n        self.generic_visit(node)\n        self.typevartuples.append(node)\n\n    # endregion\n\n    # endregion\n",
                        "size": 13671,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/services/ASTs/python_ast.py"
                      }
                    ],
                    "folders": [],
                    "name": "ASTs",
                    "size": 18600
                  }
                ],
                "name": "services",
                "size": 68120
              },
              {
                "files": [
                  {
                    "name": "__init__.py",
                    "raw": "",
                    "size": 0,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/util/__init__.py"
                  },
                  {
                    "name": "exceptions.py",
                    "raw": "from typing import Optional\n\nimport httpx\nfrom util.utilities import Log, generate_return\n\n\ndef proc_error(called_from: str, message: str, params: dict = {}, status: int = 500):\n    \"\"\"Return error results when something is wrong but did not throw exception\"\"\"\n    # Generate msg based on proc error status\n    error_message = f\"\\n\\n\\tProc.{called_from}() \\n\\tstatus: {status} \\n\\tmessage: {message} \\n\\tparam: {params} \\n\"\n    Log.error(f\"{error_message}\")\n\n    # return the error\n    return generate_return(status=status, message=message, results=params)\n\n\ndef proc_exception(\n    called_from: str,\n    message: str,\n    params: dict = {},\n    exc: Optional[Exception] = None,\n    status: int = 500,\n):\n    \"\"\"Raise an exception if there is an exception thrown in processor\"\"\"\n    import traceback\n    from fastapi import HTTPException\n\n    # log the error and stack trace\n    error_message = f\"\\n\\n\\tProc.{called_from}() \\n\\tstatus: {status} message: {message} \\n\\tparam: {params}\\n\"\n    Log.error(error_message)\n\n    # create a stack trace\n    if exc:\n        error_message = f\"\\tProc.exception: {str(exc)} \\n\\tmessage:{error_message}\\n\"\n        tbk_str = traceback.format_exception(type(exc), exc, exc.__traceback__)\n        tbk_str = \"\".join(tbk_str)\n        Log.error(f\"\\n\\t{tbk_str}\")\n\n    # raise the exception\n    if status != 500:\n        raise HTTPException(\n            status_code=status,\n            detail=error_message,\n        )\n    else:\n        raise HTTPException(\n            status_code=500,\n            detail=error_message,\n        )\n\n\nclass NotebookError(Exception):\n    \"\"\"Base class for notebook exceptions.\"\"\"\n\n    def __init__(self, source, params, message):\n        self.source = source\n        self.params = params\n        self.message = message\n\n\nclass ImportSourceUrlError(Exception):\n    \"\"\"Import Source Url error\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"Import Source Url error\",\n        status_code: int = 500,\n        exc: Exception | None = None,\n    ):\n        self.source = source\n        self.message = message\n        self.status_code = status_code\n        self.params = params\n        self.exc = exc\n\n\nclass ImportSourceUrlHttpError(httpx.RequestError):\n    \"\"\"Import Source Url Httpx error\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"Import Source Url Httpx error\",\n        status_code: int = 500,\n        exc: Exception | None = None,\n    ):\n        super().__init__(message)\n        self.source = source\n        self.params = params\n        self.status_code = status_code\n        self.exc = exc\n\n\nclass PolyGraphError(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n\n    def __init__(self, source, params, message):\n        self.source = source\n        self.params = params\n        self.message = message\n\n\nclass GravisDBError(Exception):\n    \"\"\"Base class for gravis database exceptions.\"\"\"\n\n    def __init__(self, source, params, message):\n        self.source = source\n        self.params = params\n        self.message = message\n\n\nclass GravisDBHttpError(GravisDBError):\n    \"\"\"Base class for gravis database http exceptions.\"\"\"\n\n    def __init__(self, source, params, message, status_code):\n        super().__init__(source, params, message)\n        self.status_code = status_code\n\n\nclass GithubError(Exception):\n    \"\"\"General GitHub error\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"GitHub API returned 500\",\n        status_code: int = 500,\n        exc: Exception | None = None,\n    ):\n        self.source = source\n        self.params = params\n        self.message = message\n        self.status_code = status_code\n        self.exc = exc\n\n\nclass GithubAPIError(GithubError):\n    \"\"\"GitHub API key not found\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"GitHub API key not found\",\n        status_code: int = 403,\n        exc: Exception | None = None,\n    ):\n        super().__init__(source, params, message, status_code, exc)\n\n\nclass GithubSizeError(GithubError):\n    \"\"\"GitHub repo is too large\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"GitHub repo is too large\",\n        status_code: int = 500,\n        exc: Exception | None = None,\n    ):\n        super().__init__(source, params, message, status_code, exc)\n\n\nclass GithubNoDataError(GithubError):\n    \"\"\"No data returned from GitHub API for URL\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"No data returned from GitHub API for URL\",\n        status_code: int = 404,\n        exc: Exception | None = None,\n    ):\n        super().__init__(source, params, message, status_code, exc)\n\n\nclass Github403Error(GithubError):\n    \"\"\"GitHub API returned 403\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"GitHub API returned 403\",\n        status_code: int = 403,\n        exc: Exception | None = None,\n    ):\n        super().__init__(source, params, message, status_code, exc)\n\n\nclass Github404Error(GithubError):\n    \"\"\"GitHub API returned 404\"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        params: dict,\n        message: str = \"GitHub API returned 404\",\n        status_code: int = 404,\n        exc: Exception | None = None,\n    ):\n        super().__init__(source, params, message, status_code, exc)\n",
                    "size": 5537,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/util/exceptions.py"
                  },
                  {
                    "name": "utilities.py",
                    "raw": "import logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass Log:\n    @staticmethod\n    def info(message: str):\n        logger.info(message)\n\n    @staticmethod\n    def debug(message: str):\n        logger.debug(message)\n\n    @staticmethod\n    def error(message: str):\n        logger.error(message)\n\n\ndef generate_return(\n    status: int = 200, message: str = \"\", results: str | dict | list = {}\n):\n    return {\n        \"status\": status,\n        \"message\": message,\n        \"results\": results,\n    }\n",
                    "size": 498,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/codecarto/util/utilities.py"
                  }
                ],
                "folders": [],
                "name": "util",
                "size": 6035
              }
            ],
            "name": "codecarto",
            "size": 111274
          },
          {
            "files": [
              {
                "name": "package-lock.json",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/package-lock.json",
                "size": 30846,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/package-lock.json"
              },
              {
                "name": "package.json",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/package.json",
                "size": 521,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/package.json"
              },
              {
                "name": "vite.config.js",
                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/vite.config.js",
                "size": 181,
                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/vite.config.js"
              }
            ],
            "folders": [
              {
                "files": [
                  {
                    "name": "index.html",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/index.html",
                    "size": 712,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/index.html"
                  },
                  {
                    "name": "index.ts",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/index.ts",
                    "size": 872,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/index.ts"
                  },
                  {
                    "name": "state.ts",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/state.ts",
                    "size": 1131,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/state.ts"
                  },
                  {
                    "name": "utility.ts",
                    "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/utility.ts",
                    "size": 307,
                    "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/utility.ts"
                  }
                ],
                "folders": [
                  {
                    "files": [],
                    "folders": [
                      {
                        "files": [
                          {
                            "name": "codecarto.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/codecarto/codecarto.css",
                            "size": 2701,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/codecarto/codecarto.css"
                          },
                          {
                            "name": "codecarto.ts",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/codecarto/codecarto.ts",
                            "size": 2673,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/codecarto/codecarto.ts"
                          }
                        ],
                        "folders": [],
                        "name": "codecarto",
                        "size": 5374
                      },
                      {
                        "files": [
                          {
                            "name": "Debug.js",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/debug/Debug.js",
                            "size": 1476,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/debug/Debug.js"
                          },
                          {
                            "name": "debug.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/debug/debug.css",
                            "size": 890,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/debug/debug.css"
                          },
                          {
                            "name": "tracer.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/debug/tracer.css",
                            "size": 2440,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/debug/tracer.css"
                          }
                        ],
                        "folders": [],
                        "name": "debug",
                        "size": 4806
                      },
                      {
                        "files": [],
                        "folders": [
                          {
                            "files": [
                              {
                                "name": "directory_nav.css",
                                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/directory/directory_nav.css",
                                "size": 3053,
                                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/directory/directory_nav.css"
                              },
                              {
                                "name": "directory_nav.ts",
                                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/directory/directory_nav.ts",
                                "size": 2949,
                                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/directory/directory_nav.ts"
                              }
                            ],
                            "folders": [],
                            "name": "directory",
                            "size": 6002
                          },
                          {
                            "files": [
                              {
                                "name": "upload_nav.css",
                                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/upload/upload_nav.css",
                                "size": 722,
                                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/upload/upload_nav.css"
                              },
                              {
                                "name": "upload_nav.ts",
                                "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/upload/upload_nav.ts",
                                "size": 2971,
                                "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/nav_content/upload/upload_nav.ts"
                              }
                            ],
                            "folders": [],
                            "name": "upload",
                            "size": 3693
                          }
                        ],
                        "name": "nav_content",
                        "size": 9695
                      },
                      {
                        "files": [
                          {
                            "name": "nav.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/navigation/nav.css",
                            "size": 581,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/navigation/nav.css"
                          },
                          {
                            "name": "nav.ts",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/navigation/nav.ts",
                            "size": 1370,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/navigation/nav.ts"
                          }
                        ],
                        "folders": [],
                        "name": "navigation",
                        "size": 1951
                      },
                      {
                        "files": [
                          {
                            "name": "plot.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/plot/plot.css",
                            "size": 336,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/plot/plot.css"
                          },
                          {
                            "name": "plot.ts",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/plot/plot.ts",
                            "size": 242,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/plot/plot.ts"
                          }
                        ],
                        "folders": [],
                        "name": "plot",
                        "size": 578
                      },
                      {
                        "files": [
                          {
                            "name": "url_input.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/url_input/url_input.css",
                            "size": 365,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/url_input/url_input.css"
                          },
                          {
                            "name": "url_input.ts",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/url_input/url_input.ts",
                            "size": 1111,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/components/url_input/url_input.ts"
                          }
                        ],
                        "folders": [],
                        "name": "url_input",
                        "size": 1476
                      }
                    ],
                    "name": "components",
                    "size": 23880
                  },
                  {
                    "files": [
                      {
                        "name": "demo.txt",
                        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/demo/demo.txt",
                        "size": 509584,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/demo/demo.txt"
                      }
                    ],
                    "folders": [],
                    "name": "demo",
                    "size": 509584
                  },
                  {
                    "files": [
                      {
                        "name": "demo_service.ts",
                        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/services/demo_service.ts",
                        "size": 444,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/services/demo_service.ts"
                      },
                      {
                        "name": "repo_service.ts",
                        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/services/repo_service.ts",
                        "size": 9906,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/services/repo_service.ts"
                      },
                      {
                        "name": "request_handler.ts",
                        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/services/request_handler.ts",
                        "size": 2917,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/services/request_handler.ts"
                      }
                    ],
                    "folders": [],
                    "name": "services",
                    "size": 13267
                  },
                  {
                    "files": [
                      {
                        "name": "index.css",
                        "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/index.css",
                        "size": 606,
                        "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/index.css"
                      }
                    ],
                    "folders": [
                      {
                        "files": [
                          {
                            "name": "accessibility.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/root/accessibility.css",
                            "size": 125,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/root/accessibility.css"
                          },
                          {
                            "name": "normalize.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/root/normalize.css",
                            "size": 5182,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/root/normalize.css"
                          },
                          {
                            "name": "root.css",
                            "raw": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/root/root.css",
                            "size": 707,
                            "url": "https://raw.githubusercontent.com/quaternionmedia/codecartographer/main/src/web/src/styles/root/root.css"
                          }
                        ],
                        "folders": [],
                        "name": "root",
                        "size": 6014
                      }
                    ],
                    "name": "styles",
                    "size": 6620
                  }
                ],
                "name": "src",
                "size": 556373
              }
            ],
            "name": "web",
            "size": 587921
          }
        ],
        "name": "src",
        "size": 699195
      }
    ],
    "name": "quaternionmedia/codecartographer",
    "size": 894623
  },
  "size": 894623
}
